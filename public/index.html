<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CEREBELLAR-EXTRACT - Data Extraction Tool</title>

  <!-- Firebase SDKs (Compat) -->
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-functions-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-analytics-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-performance-compat.js"></script>

  <!-- PDF.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>

  <!-- React & ReactDOM -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>

  <!-- Babel for JSX -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <!-- Fuzzysort for fuzzy text matching (citation jumps) -->
  <script src="https://unpkg.com/fuzzysort@3.0.2/fuzzysort.min.js"></script>

  <style>
    /* Reset and base styles */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --primary: #3498db;
      --primary-dark: #2980b9;
      --secondary: #2c3e50;
      --accent: #f39c12;
      --accent-hover: #e67e22;
      --ai-color: #8e44ad;
      --ai-bg: #f5eef8;
      --success: #27ae60;
      --bg-grey: #eef2f5;
      --border: #dce4ec;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: var(--bg-grey);
      color: #333;
    }

    .app {
      display: flex;
      height: 100vh;
      overflow: hidden;
    }

    /* --- LEFT PANEL: PDF VIEWER --- */
    .pdf-panel {
      flex: 1;
      display: flex;
      flex-direction: column;
      background: #525659;
      /* Neutral dark grey for PDF backdrop */
      color: white;
      overflow: hidden;
      position: relative;
    }

    .pdf-header {
      padding: 12px 20px;
      background: #323639;
      border-bottom: 1px solid #000;
      display: flex;
      justify-content: space-between;
      align-items: center;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      z-index: 10;
    }

    .pdf-header h2 {
      font-size: 16px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    /* File upload styling */
    .file-upload-btn {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 16px;
      background: var(--primary);
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      transition: background 0.2s;
      position: relative;
      overflow: hidden;
    }

    .file-upload-btn:hover {
      background: var(--primary-dark);
    }

    .file-upload-btn input[type="file"] {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      opacity: 0;
      cursor: pointer;
    }

    /* Controls Bar */
    .pdf-controls {
      padding: 8px 16px;
      background: #424649;
      display: flex;
      gap: 8px;
      align-items: center;
      justify-content: center;
      border-bottom: 1px solid #000;
    }

    .control-btn {
      padding: 4px 8px;
      background: transparent;
      color: #f0f0f0;
      border: 1px solid #666;
      border-radius: 3px;
      cursor: pointer;
      font-size: 12px;
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .control-btn:hover:not(:disabled) {
      background: rgba(255, 255, 255, 0.1);
    }

    .control-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* Annotation Bar */
    .annotation-bar {
      padding: 10px 16px;
      background: #fff;
      display: flex;
      gap: 12px;
      align-items: center;
      border-bottom: 1px solid var(--border);
      color: #333;
    }

    .field-select {
      padding: 6px 10px;
      border-radius: 4px;
      border: 1px solid var(--border);
      background: white;
      font-size: 13px;
      min-width: 200px;
    }

    .toggle-highlight-btn {
      padding: 6px 12px;
      background: var(--bg-grey);
      color: #555;
      border: 1px solid var(--border);
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: 6px;
      transition: all 0.2s;
    }

    .toggle-highlight-btn.active {
      background: #fff3cd;
      color: #856404;
      border-color: #ffeeba;
      box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.05);
    }

    .toggle-highlight-btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    /* PDF Canvas Container */
    .pdf-viewer-container {
      flex: 1;
      overflow: auto;
      padding: 40px;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      background-image: radial-gradient(#666 1px, transparent 1px);
      background-size: 20px 20px;
    }

    .pdf-canvas-wrapper {
      position: relative;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.4);
      background: white;
    }

    #pdf-canvas {
      display: block;
    }

    .highlight-layer {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
    }

    .highlight {
      position: absolute;
      background: rgba(255, 235, 59, 0.3);
      border: 1px solid rgba(255, 193, 7, 0.8);
      pointer-events: auto;
      cursor: pointer;
      transition: opacity 0.2s;
    }

    .highlight:hover {
      background: rgba(255, 235, 59, 0.5);
      z-index: 10;
    }

    /* Citation highlights (from Claude Native Citations) */
    .citation-highlight {
      position: absolute;
      background: rgba(138, 43, 226, 0.25);
      border: 1px solid rgba(138, 43, 226, 0.6);
      pointer-events: auto;
      cursor: pointer;
      transition: all 0.2s;
      border-radius: 2px;
    }

    .citation-highlight:hover {
      background: rgba(138, 43, 226, 0.4);
      z-index: 10;
    }

    .citation-highlight.active {
      background: rgba(138, 43, 226, 0.5);
      border-width: 2px;
      box-shadow: 0 0 8px rgba(138, 43, 226, 0.5);
    }

    /* Citation jump highlight - starts yellow, transitions to persistent border */
    .citation-jump-highlight {
      position: absolute;
      background: rgba(255, 235, 59, 0.6);
      border: 2px solid #FFC107;
      border-radius: 3px;
      pointer-events: auto;
      cursor: pointer;
      animation: citation-pulse 0.5s ease-in-out 3;
      transition: background 0.5s ease, border-color 0.5s ease;
    }

    .citation-jump-highlight.persistent {
      background: rgba(255, 235, 59, 0.15);
      border: 2px dashed #FF9800;
      animation: none;
    }

    .citation-jump-highlight:hover {
      background: rgba(255, 235, 59, 0.4);
      border-style: solid;
      z-index: 100;
    }

    @keyframes citation-pulse {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.7; transform: scale(1.02); }
    }

    /* Citation highlight tooltip */
    .citation-tooltip {
      position: absolute;
      bottom: calc(100% + 5px);
      left: 50%;
      transform: translateX(-50%);
      background: #333;
      color: white;
      padding: 6px 10px;
      border-radius: 4px;
      font-size: 11px;
      white-space: nowrap;
      max-width: 280px;
      overflow: hidden;
      text-overflow: ellipsis;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.2s, visibility 0.2s;
      z-index: 1000;
      pointer-events: none;
    }

    .citation-tooltip::after {
      content: '';
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      border: 5px solid transparent;
      border-top-color: #333;
    }

    .citation-jump-highlight:hover .citation-tooltip {
      opacity: 1;
      visibility: visible;
    }

    /* Citation button in form fields */
    .btn-citation {
      background: transparent;
      border: none;
      padding: 4px 6px;
      cursor: pointer;
      color: #6c757d;
      transition: all 0.2s;
      border-radius: 4px;
      font-size: 14px;
    }

    .btn-citation:hover {
      background: #e3f2fd;
      color: #1976d2;
    }

    .btn-citation:active {
      transform: scale(0.95);
    }

    .btn-citation.has-citation {
      color: #4CAF50;
    }

    .btn-citation.has-citation:hover {
      background: #e8f5e9;
      color: #2e7d32;
    }

    /* Citation panel styles */
    .citation-panel {
      background: #f8f4ff;
      border: 1px solid #d4c4e8;
      border-radius: 6px;
      margin-bottom: 15px;
      overflow: hidden;
    }

    .citation-panel-header {
      padding: 10px 12px;
      background: linear-gradient(135deg, #8e44ad, #9b59b6);
      color: white;
      font-size: 13px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .citation-card {
      padding: 10px 12px;
      border-bottom: 1px solid #e8dff2;
      cursor: pointer;
      transition: background 0.2s;
    }

    .citation-card:last-child {
      border-bottom: none;
    }

    .citation-card:hover {
      background: #f0e8f8;
    }

    .citation-card.active {
      background: #e8d8f4;
      border-left: 3px solid #8e44ad;
    }

    .citation-field {
      font-size: 11px;
      font-weight: 600;
      color: #8e44ad;
      text-transform: uppercase;
      margin-bottom: 4px;
    }

    .citation-value {
      font-size: 13px;
      color: #2c3e50;
      margin-bottom: 6px;
    }

    .citation-source {
      font-size: 11px;
      color: #666;
      font-style: italic;
      background: white;
      padding: 6px 8px;
      border-radius: 4px;
      border-left: 2px solid #9b59b6;
      max-height: 60px;
      overflow-y: auto;
    }

    .citation-meta {
      font-size: 10px;
      color: #999;
      margin-top: 6px;
      display: flex;
      gap: 12px;
    }

    /* --- RIGHT PANEL: EXTRACTION FORM --- */
    .extraction-panel {
      width: 480px;
      background: white;
      display: flex;
      flex-direction: column;
      border-left: 1px solid var(--border);
      box-shadow: -2px 0 10px rgba(0, 0, 0, 0.05);
      z-index: 20;
    }

    .extraction-header {
      padding: 20px 20px 0 20px;
      /* Reduced bottom padding for tabs */
      background: white;
      border-bottom: 1px solid var(--border);
    }

    .header-title-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 5px;
    }

    .extraction-header h2 {
      font-size: 18px;
      color: var(--secondary);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .save-status {
      font-size: 11px;
      color: #7f8c8d;
      display: flex;
      align-items: center;
      gap: 4px;
      background: #f8f9fa;
      padding: 2px 8px;
      border-radius: 12px;
      border: 1px solid #eee;
    }

    .save-status.saving {
      color: var(--accent);
    }

    .save-status.saved {
      color: var(--success);
    }

    /* TABS */
    .panel-tabs {
      display: flex;
      gap: 20px;
      margin-top: 10px;
    }

    .tab-btn {
      background: none;
      border: none;
      padding: 8px 0;
      font-size: 13px;
      font-weight: 600;
      color: #7f8c8d;
      cursor: pointer;
      position: relative;
    }

    .tab-btn.active {
      color: var(--primary);
    }

    .tab-btn.active::after {
      content: '';
      position: absolute;
      bottom: -1px;
      /* Overlap border */
      left: 0;
      right: 0;
      height: 2px;
      background: var(--primary);
    }

    /* AI Buttons */
    .btn-ai-magic {
      padding: 6px 12px;
      font-size: 12px;
      font-weight: 600;
      background: linear-gradient(135deg, #8e44ad, #9b59b6);
      color: white;
      border: none;
      border-radius: 20px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 6px;
      box-shadow: 0 2px 5px rgba(142, 68, 173, 0.3);
      transition: transform 0.1s, box-shadow 0.1s;
    }

    .btn-ai-magic:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(142, 68, 173, 0.4);
    }

    /* VerifiableField Component - Human-in-the-Loop Review */
    .verifiable-field {
      background: white;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 12px;
      transition: border-color 0.2s, box-shadow 0.2s;
    }

    .verifiable-field:hover {
      border-color: var(--primary);
      box-shadow: 0 2px 8px rgba(52, 152, 219, 0.1);
    }

    .verifiable-field.verified {
      border-color: var(--success);
      background: #f0fff4;
    }

    .verifiable-field.flagged {
      border-color: var(--accent);
      background: #fff9e6;
    }

    .verifiable-field-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }

    .verifiable-field-label {
      font-size: 11px;
      font-weight: 600;
      color: #7f8c8d;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .verifiable-field-value {
      font-size: 16px;
      font-weight: 600;
      color: #2c3e50;
      margin-bottom: 8px;
    }

    .verifiable-field-source {
      background: #f8f9fa;
      border-left: 3px solid var(--ai-color);
      padding: 8px 12px;
      font-size: 12px;
      color: #555;
      font-style: italic;
      border-radius: 0 4px 4px 0;
      margin-bottom: 8px;
    }

    .verifiable-field-source::before {
      content: '"';
    }

    .verifiable-field-source::after {
      content: '"';
    }

    .verifiable-field-page {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 3px 8px;
      background: var(--bg-grey);
      border: 1px solid var(--border);
      border-radius: 4px;
      font-size: 11px;
      color: #666;
      cursor: pointer;
      transition: all 0.2s;
    }

    .verifiable-field-page:hover {
      background: var(--primary);
      color: white;
      border-color: var(--primary);
    }

    .verifiable-field-actions {
      display: flex;
      gap: 6px;
      margin-top: 8px;
    }

    .verify-btn {
      padding: 4px 10px;
      font-size: 11px;
      border-radius: 4px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 4px;
      transition: all 0.2s;
    }

    .verify-btn.approve {
      background: #e8f5e9;
      color: #27ae60;
      border: 1px solid #27ae60;
    }

    .verify-btn.approve:hover {
      background: #27ae60;
      color: white;
    }

    .verify-btn.flag {
      background: #fff3cd;
      color: #856404;
      border: 1px solid #ffc107;
    }

    .verify-btn.flag:hover {
      background: #ffc107;
      color: #333;
    }

    /* Review Panel */
    .review-panel {
      padding: 20px;
      overflow-y: auto;
      height: 100%;
    }

    .review-header {
      margin-bottom: 20px;
      padding-bottom: 15px;
      border-bottom: 1px solid var(--border);
    }

    .review-title {
      font-size: 18px;
      font-weight: 700;
      color: #2c3e50;
      margin-bottom: 4px;
    }

    .review-meta {
      font-size: 13px;
      color: #7f8c8d;
    }

    .review-section {
      margin-bottom: 24px;
    }

    .review-section-title {
      font-size: 14px;
      font-weight: 700;
      color: var(--secondary);
      margin-bottom: 12px;
      padding-bottom: 6px;
      border-bottom: 2px solid var(--primary);
      display: inline-block;
    }

    .review-progress {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 16px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border-radius: 8px;
      margin-bottom: 20px;
    }

    .review-progress-bar {
      flex: 1;
      height: 8px;
      background: rgba(255, 255, 255, 0.3);
      border-radius: 4px;
      overflow: hidden;
    }

    .review-progress-fill {
      height: 100%;
      background: white;
      border-radius: 4px;
      transition: width 0.3s ease;
    }

    .review-progress-text {
      font-size: 13px;
      font-weight: 600;
      white-space: nowrap;
    }

    .btn-ai-magic:active {
      transform: translateY(0);
    }

    .btn-ai-magic:disabled {
      background: #ccc;
      box-shadow: none;
      cursor: not-allowed;
    }

    .btn-quality-check {
      padding: 4px 8px;
      font-size: 11px;
      background: #f8f9fa;
      color: var(--ai-color);
      border: 1px solid var(--ai-color);
      border-radius: 4px;
      cursor: pointer;
      margin-left: auto;
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .btn-quality-check:hover {
      background: var(--ai-bg);
    }

    /* Form Body */
    .extraction-content {
      flex: 1;
      overflow-y: auto;
      background: #fcfcfc;
      position: relative;
    }

    .extraction-form-container {
      padding: 20px;
    }

    /* Chat Interface */
    .chat-container {
      display: flex;
      flex-direction: column;
      height: 100%;
      background: #f8f9fa;
    }

    .chat-messages {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .message {
      max-width: 85%;
      padding: 10px 14px;
      border-radius: 12px;
      font-size: 13px;
      line-height: 1.4;
      position: relative;
    }

    .message.user {
      align-self: flex-end;
      background: var(--primary);
      color: white;
      border-bottom-right-radius: 2px;
    }

    .message.assistant {
      align-self: flex-start;
      background: white;
      border: 1px solid var(--border);
      color: #2c3e50;
      border-bottom-left-radius: 2px;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
    }

    .message.system {
      align-self: center;
      background: transparent;
      color: #7f8c8d;
      font-size: 11px;
      font-style: italic;
      border: none;
      box-shadow: none;
      text-align: center;
    }

    .quick-prompts {
      display: flex;
      gap: 8px;
      padding: 10px 15px;
      overflow-x: auto;
      white-space: nowrap;
      border-top: 1px solid var(--border);
      background: white;
      -ms-overflow-style: none;
      /* IE and Edge */
      scrollbar-width: none;
      /* Firefox */
    }

    .quick-prompts::-webkit-scrollbar {
      display: none;
    }

    .prompt-pill {
      padding: 6px 12px;
      background: #f0f2f5;
      color: #555;
      border: 1px solid #e4e6eb;
      border-radius: 16px;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.2s;
      flex-shrink: 0;
    }

    .prompt-pill:hover {
      background: var(--ai-bg);
      color: var(--ai-color);
      border-color: var(--ai-color);
    }

    .chat-input-area {
      padding: 15px;
      background: white;
      border-top: 1px solid var(--border);
      display: flex;
      gap: 8px;
    }

    .chat-input {
      flex: 1;
      padding: 8px 12px;
      border: 1px solid var(--border);
      border-radius: 20px;
      font-size: 13px;
      outline: none;
    }

    .chat-input:focus {
      border-color: var(--primary);
    }

    .btn-send {
      background: var(--primary);
      color: white;
      border: none;
      width: 36px;
      height: 36px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }

    /* Accordion Sections */
    .form-section {
      margin-bottom: 20px;
      background: white;
      border: 1px solid var(--border);
      border-radius: 6px;
      overflow: hidden;
    }

    .form-section:last-child {
      margin-bottom: 0;
    }

    .section-header {
      padding: 12px 15px;
      background: #f8f9fa;
      border-bottom: 1px solid var(--border);
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer;
      -webkit-user-select: none;
      user-select: none;
      transition: background 0.2s;
    }

    .section-header:hover {
      background: #eef2f5;
    }

    .section-title {
      font-size: 14px;
      font-weight: 600;
      color: var(--secondary);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .section-actions {
      display: flex;
      gap: 8px;
    }

    .btn-clear-section {
      padding: 2px 6px;
      font-size: 10px;
      color: #999;
      background: transparent;
      border: 1px solid #ddd;
      border-radius: 3px;
      cursor: pointer;
    }

    .btn-clear-section:hover {
      background: #fee;
      color: #c0392b;
      border-color: #e74c3c;
    }

    .section-body {
      padding: 15px;
      display: block;
    }

    .section-body.collapsed {
      display: none;
    }

    /* Form Inputs */
    .form-group {
      margin-bottom: 14px;
      position: relative;
    }

    .form-group label {
      display: block;
      font-size: 12px;
      font-weight: 600;
      color: #7f8c8d;
      margin-bottom: 6px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .input-wrapper {
      position: relative;
      display: flex;
      align-items: stretch;
    }

    .form-control {
      flex: 1;
      width: 100%;
      padding: 10px 12px;
      padding-right: 35px;
      /* space for badge */
      border: 1px solid var(--border);
      border-radius: 4px;
      font-size: 14px;
      line-height: 1.5;
      color: #2c3e50;
      transition: all 0.2s;
      background: white;
    }

    .input-wrapper textarea.form-control {
      padding-right: 12px;
      /* Textarea suggestion button is outside or floating */
    }

    .form-control:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
      z-index: 2;
    }

    textarea.form-control {
      min-height: 70px;
      resize: vertical;
    }

    /* Input Actions (Magic Wand) */
    .input-actions {
      position: absolute;
      right: 8px;
      top: 50%;
      transform: translateY(-50%);
      display: flex;
      gap: 4px;
      z-index: 5;
    }

    textarea~.input-actions {
      top: 12px;
      transform: none;
    }

    .btn-suggest {
      background: none;
      border: none;
      cursor: pointer;
      color: #bdc3c7;
      padding: 2px;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
    }

    .btn-suggest:hover {
      color: var(--ai-color);
      background: var(--ai-bg);
      transform: scale(1.1);
    }

    .btn-suggest.loading {
      animation: spin 1s linear infinite;
      color: var(--ai-color);
      cursor: wait;
    }

    /* AI Filled State */
    .form-control.ai-filled {
      border-color: #d2b4de;
      background: linear-gradient(to right, #fff, #fcf4ff);
    }

    .ai-badge {
      position: absolute;
      right: -20px;
      /* Outside */
      top: 10px;
      font-size: 14px;
      color: var(--ai-color);
      pointer-events: none;
      animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }

    /* Selected State for highlighting */
    .form-control.field-focused {
      border-color: var(--accent);
      background: #fffcf5;
    }

    /* Footer Actions */
    .panel-footer {
      padding: 15px 20px;
      background: white;
      border-top: 1px solid var(--border);
      display: flex;
      gap: 12px;
    }

    .action-btn {
      flex: 1;
      padding: 12px;
      border: none;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      transition: all 0.2s;
    }

    .btn-export-json {
      background: #27ae60;
      color: white;
    }

    .btn-export-json:hover {
      background: #219150;
    }

    .btn-export-sheets {
      background: #fff;
      color: #27ae60;
      border: 1px solid #27ae60;
    }

    .btn-export-sheets:hover {
      background: #f0f9f4;
    }

    /* Annotations List */
    .annotations-container {
      margin-top: 20px;
    }

    .annotation-card {
      padding: 10px;
      background: white;
      border: 1px solid var(--border);
      border-left: 3px solid var(--accent);
      border-radius: 4px;
      margin-bottom: 8px;
      font-size: 12px;
      cursor: pointer;
      transition: transform 0.2s;
    }

    .annotation-card:hover {
      transform: translateX(2px);
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
    }

    .annotation-card strong {
      color: var(--secondary);
      display: block;
      margin-bottom: 4px;
    }

    .annotation-card p {
      color: #666;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* Toast & Loading */
    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(255, 255, 255, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 100;
      -webkit-backdrop-filter: blur(2px);
      backdrop-filter: blur(2px);
    }

    .spinner {
      width: 40px;
      height: 40px;
      border: 4px solid #f3f3f3;
      border-top: 4px solid var(--ai-color);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% {
        transform: rotate(0deg);
      }

      100% {
        transform: rotate(360deg);
      }
    }

    @keyframes popIn {
      0% {
        transform: scale(0);
      }

      100% {
        transform: scale(1);
      }
    }

    .toast {
      position: fixed;
      bottom: 24px;
      right: 24px;
      padding: 12px 24px;
      background: #333;
      color: white;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      z-index: 1000;
      font-size: 14px;
      display: flex;
      align-items: center;
      gap: 8px;
      animation: slideUp 0.3s ease;
    }

    .toast.error {
      background: #e74c3c;
    }

    .toast.success {
      background: #27ae60;
    }

    @keyframes slideUp {
      from {
        transform: translateY(20px);
        opacity: 0;
      }

      to {
        transform: translateY(0);
        opacity: 1;
      }
    }

    /* Scrollbar polish */
    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }

    ::-webkit-scrollbar-track {
      background: transparent;
    }

    ::-webkit-scrollbar-thumb {
      background: #cbd5e0;
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: #a0aec0;
    }

    /* ============================================
       DETAILED EXTRACTION: Grid Layouts & Dynamic Fields
       ============================================ */

    /* Grid Layouts for Detailed Extraction */
    .grid-2col {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 16px;
      margin-bottom: 16px;
    }

    .grid-3col {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 12px;
      margin-bottom: 16px;
    }

    /* mRS Distribution Grid (7 columns for scores 0-6) */
    .grid-mrs {
      display: grid;
      grid-template-columns: repeat(7, 1fr);
      gap: 8px;
      margin-bottom: 16px;
    }

    .grid-mrs .form-group {
      margin-bottom: 0;
    }

    .grid-mrs .form-group label {
      text-align: center;
      font-weight: 600;
      color: var(--primary);
      margin-bottom: 4px;
      font-size: 14px;
    }

    .grid-mrs .form-group input {
      text-align: center;
      font-size: 14px;
    }

    /* Dynamic Field Container */
    .dynamic-container {
      background: #ffffff;
      border: 2px solid var(--border);
      border-radius: 8px;
      padding: 20px;
      margin-bottom: 16px;
      position: relative;
      transition: all 0.2s ease;
    }

    .dynamic-container:hover {
      border-color: var(--primary);
      box-shadow: 0 2px 8px rgba(52, 152, 219, 0.1);
    }

    .dynamic-container h4 {
      color: var(--secondary);
      font-size: 16px;
      margin-bottom: 16px;
      padding-bottom: 8px;
      border-bottom: 2px solid var(--border);
    }

    .dynamic-container h5 {
      color: var(--primary);
      font-size: 14px;
      margin: 12px 0 8px 0;
      font-weight: 600;
    }

    /* Remove Button for Dynamic Fields */
    .remove-btn {
      position: absolute;
      top: 12px;
      right: 12px;
      padding: 6px 12px;
      background: #e74c3c;
      color: white;
      border: none;
      border-radius: 4px;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .remove-btn:hover {
      background: #c0392b;
      transform: scale(1.05);
    }

    /* Add Field Button */
    .add-field-btn {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 10px 16px;
      background: var(--success);
      color: white;
      border: none;
      border-radius: 4px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      margin-bottom: 16px;
    }

    .add-field-btn:hover {
      background: #229954;
      transform: translateY(-1px);
      box-shadow: 0 2px 8px rgba(39, 174, 96, 0.3);
    }

    .add-field-btn svg {
      width: 16px;
      height: 16px;
    }

    /* Field Section Headers */
    .field-section {
      margin-bottom: 32px;
    }

    .field-section>h3 {
      color: var(--secondary);
      font-size: 18px;
      margin-bottom: 16px;
      padding-bottom: 8px;
      border-bottom: 3px solid var(--primary);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .field-section-description {
      color: #666;
      font-size: 13px;
      margin-bottom: 12px;
      font-style: italic;
    }

    /* Arm Selector Specific Styling */
    .arm-selector {
      width: 100%;
      padding: 8px;
      border: 1px solid var(--border);
      border-radius: 4px;
      font-size: 14px;
    }

    .arm-selector:focus {
      border-color: var(--primary);
      outline: none;
      box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
    }

    /* Empty State for Dynamic Fields */
    .empty-state {
      text-align: center;
      padding: 40px 20px;
      color: #999;
      font-style: italic;
    }

    .empty-state svg {
      width: 48px;
      height: 48px;
      margin-bottom: 12px;
      opacity: 0.3;
    }
  </style>
</head>

<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useRef, useCallback } = React;

    // --- GLOBAL CONFIGURATION ---

    // Firebase Config - Updated for Firebase AI Logic / Data Connect
    const firebaseConfig = {
      apiKey: "AIzaSyAMr_rIvuAvRyvAcAsLTBOLrKiw8ikvQFQ",
      authDomain: "cerebellar-extraction.firebaseapp.com",
      projectId: "cerebellar-extraction",
      storageBucket: "cerebellar-extraction.firebasestorage.app",
      messagingSenderId: "1019192870442",
      appId: "1:1019192870442:web:0bea61ff2c9435c63c6553",
      measurementId: "G-GH46289Z2Z"
    };

    // Initialize Firebase
    if (!firebase.apps.length) {
      firebase.initializeApp(firebaseConfig);
    }
    const app = firebase.app();
    const auth = firebase.auth();
    const db = firebase.firestore();
    const analytics = firebase.analytics();
    const perf = firebase.performance();

    const appId = "cerebellar-extraction";
    const apiKey = "AIzaSyBJQLItldk8YHZl9pCs40zbo6LDkGdYGwA"; // Gemini API key

    // Inline SVGs to replace Lucide Icons
    const Icons = {
      Wand2: (props) => <svg xmlns="http://www.w3.org/2000/svg" width={props.size || 24} height={props.size || 24} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="m21.64 3.64-1.28-1.28a1.21 1.21 0 0 0-1.72 0L2.36 18.64a1.21 1.21 0 0 0 0 1.72l1.28 1.28a1.2 1.2 0 0 0 1.72 0L21.64 5.36a1.2 1.2 0 0 0 0-1.72Z" /><path d="m14 7 3 3" /><path d="M5 6v4" /><path d="M19 14v4" /><path d="M10 2v2" /><path d="M7 8H3" /><path d="M21 16h-4" /><path d="M11 3H9" /></svg>,
      MessageSquare: (props) => <svg xmlns="http://www.w3.org/2000/svg" width={props.size || 24} height={props.size || 24} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z" /></svg>,
      FileText: (props) => <svg xmlns="http://www.w3.org/2000/svg" width={props.size || 24} height={props.size || 24} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z" /><polyline points="14 2 14 8 20 8" /><line x1="16" x2="8" y1="13" y2="13" /><line x1="16" x2="8" y1="17" y2="17" /><line x1="10" x2="8" y1="9" y2="9" /></svg>,
      Send: (props) => <svg xmlns="http://www.w3.org/2000/svg" width={props.size || 24} height={props.size || 24} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="m22 2-7 20-4-9-9-4Z" /><path d="M22 2 11 13" /></svg>,
      ChevronDown: (props) => <svg xmlns="http://www.w3.org/2000/svg" width={props.size || 24} height={props.size || 24} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="m6 9 6 6 6-6" /></svg>,
      ChevronRight: (props) => <svg xmlns="http://www.w3.org/2000/svg" width={props.size || 24} height={props.size || 24} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="m9 18 6-6-6-6" /></svg>,
      Quote: (props) => <svg xmlns="http://www.w3.org/2000/svg" width={props.size || 24} height={props.size || 24} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="M3 21c3 0 7-1 7-8V5c0-1.25-.756-2.017-2-2H4c-1.25 0-2 .75-2 1.972V11c0 1.25.75 2 2 2 1 0 1 0 1 1v1c0 1-1 2-2 2s-1 .008-1 1.031V20c0 1 0 1 1 1z" /><path d="M15 21c3 0 7-1 7-8V5c0-1.25-.757-2.017-2-2h-4c-1.25 0-2 .75-2 1.972V11c0 1.25.75 2 2 2 1 0 1 0 1 1v1c0 1-1 2-2 2s-1 .008-1 1.031V20c0 1 0 1 1 1z" /></svg>,
      Activity: (props) => <svg xmlns="http://www.w3.org/2000/svg" width={props.size || 24} height={props.size || 24} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="M22 12h-4l-3 9L9 3l-3 9H2" /></svg>,
      Cloud: (props) => <svg xmlns="http://www.w3.org/2000/svg" width={props.size || 24} height={props.size || 24} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="M17.5 19c0-1.7-1.3-3-3-3h-11a3 3 0 0 1-.3-6 5 5 0 0 1 9.7-1.5 4 4 0 0 1 7.9 2.3 2.2 2.2 0 0 1 .2.9 2.5 2.5 0 0 1-2.5 2.3Z" /></svg>,
      Check: (props) => <svg xmlns="http://www.w3.org/2000/svg" width={props.size || 24} height={props.size || 24} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="M20 6 9 17l-5-5" /></svg>,
      Database: (props) => <svg xmlns="http://www.w3.org/2000/svg" width={props.size || 24} height={props.size || 24} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><ellipse cx="12" cy="5" rx="9" ry="3" /><path d="M3 5v14c0 1.66 4.03 3 9 3s9-1.34 9-3V5" /><path d="M3 12c0 1.66 4.03 3 9 3s9-1.34 9-3" /></svg>,
      Table: (props) => <svg xmlns="http://www.w3.org/2000/svg" width={props.size || 24} height={props.size || 24} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><rect width="18" height="18" x="3" y="3" rx="2" /><path d="M3 9h18" /><path d="M3 15h18" /><path d="M9 3v18" /></svg>,
      Image: (props) => <svg xmlns="http://www.w3.org/2000/svg" width={props.size || 24} height={props.size || 24} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><rect width="18" height="18" x="3" y="3" rx="2" ry="2" /><circle cx="9" cy="9" r="2" /><path d="m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21" /></svg>
    };

    const FIELD_MAP = {
      "Study ID": "study_id",
      "Authors": "authors",
      "Year": "year",
      "Title": "title",
      "Sample Size": "population.sample_size",
      "Mean Age": "population.mean_age",
      "Inclusion Criteria": "population.inclusion_criteria",
      "Intervention": "intervention.procedure",
      "Intervention Timing": "intervention.timing_hours",
      "Intervention Technique": "intervention.technique",
      "Comparator": "comparator",
      "Mortality": "outcomes.mortality",
      "mRS Outcome": "outcomes.mRS_favorable",
      "Complications": "outcomes.complications",
      "Length of Stay": "outcomes.length_of_stay",
      "Follow-up Duration": "timing.follow_up_duration",
      "Study Design": "study_design",
      "Newcastle-Ottawa Score": "newcastle_ottawa_score"
    };

    const GEMINI_SCHEMA = {
      type: "OBJECT",
      properties: {
        study_id: { type: "STRING", description: "First author last name + year e.g. Smith2023" },
        authors: { type: "STRING", description: "Authors string e.g. Smith et al." },
        year: { type: "STRING" },
        title: { type: "STRING" },
        population: {
          type: "OBJECT",
          properties: {
            sample_size: { type: "STRING" },
            mean_age: { type: "STRING" },
            inclusion_criteria: { type: "STRING" },
          }
        },
        intervention: {
          type: "OBJECT",
          properties: {
            procedure: { type: "STRING" },
            timing_hours: { type: "STRING" },
            technique: { type: "STRING" }
          }
        },
        outcomes: {
          type: "OBJECT",
          properties: {
            mortality: { type: "STRING" },
            mRS_favorable: { type: "STRING" },
            complications: { type: "STRING" },
            length_of_stay: { type: "STRING" }
          }
        },
        study_design: { type: "STRING" },
        // Dynamic field types for detailed extraction
        studyArms: {
          type: "ARRAY",
          description: "Treatment groups or cohorts in the study",
          items: {
            type: "OBJECT",
            properties: {
              label: { type: "STRING", description: "Arm name (e.g., 'SDC', 'Control')" },
              sampleSize: { type: "STRING", description: "Number of patients in this arm" }
            }
          }
        },
        indications: {
          type: "ARRAY",
          description: "Surgical indications for the procedure",
          items: {
            type: "OBJECT",
            properties: {
              sign: { type: "STRING", description: "Clinical indication or symptom" },
              count: { type: "STRING", description: "Number or frequency of patients with this indication" }
            }
          }
        },
        interventions: {
          type: "ARRAY",
          description: "Surgical techniques or procedures performed",
          items: {
            type: "OBJECT",
            properties: {
              type: { type: "STRING", description: "Type of surgical technique" },
              timeToSurgery: { type: "STRING", description: "Time from admission/diagnosis to surgery" },
              duraplasty: { type: "STRING", description: "Duraplasty used: 'yes', 'no', or 'null'" }
            }
          }
        },
        mortalities: {
          type: "ARRAY",
          description: "Mortality data by study arm and timepoint",
          items: {
            type: "OBJECT",
            properties: {
              arm: { type: "STRING", description: "Study arm label" },
              timepoint: { type: "STRING", description: "When mortality was measured (e.g., '30-day', 'in-hospital')" },
              deaths: { type: "STRING", description: "Number of deaths" },
              total: { type: "STRING", description: "Total patients at risk" }
            }
          }
        },
        mrsScores: {
          type: "ARRAY",
          description: "Modified Rankin Scale score distributions by arm",
          items: {
            type: "OBJECT",
            properties: {
              arm: { type: "STRING", description: "Study arm label" },
              timepoint: { type: "STRING", description: "When mRS was assessed" },
              scores: {
                type: "OBJECT",
                description: "Count of patients at each mRS score (0-6)",
                properties: {
                  "0": { type: "STRING" },
                  "1": { type: "STRING" },
                  "2": { type: "STRING" },
                  "3": { type: "STRING" },
                  "4": { type: "STRING" },
                  "5": { type: "STRING" },
                  "6": { type: "STRING" }
                }
              }
            }
          }
        },
        complications: {
          type: "ARRAY",
          description: "Adverse events or complications by study arm",
          items: {
            type: "OBJECT",
            properties: {
              description: { type: "STRING", description: "Type of complication" },
              arm: { type: "STRING", description: "Study arm label" },
              count: { type: "STRING", description: "Number of occurrences" }
            }
          }
        },
        predictors: {
          type: "ARRAY",
          description: "Statistical predictors of outcomes (OR, HR, RR with confidence intervals)",
          items: {
            type: "OBJECT",
            properties: {
              variable: { type: "STRING", description: "Predictor variable name" },
              effectSize: { type: "STRING", description: "Effect size (OR, HR, RR)" },
              ciLower: { type: "STRING", description: "Lower bound of 95% CI" },
              ciUpper: { type: "STRING", description: "Upper bound of 95% CI" },
              pValue: { type: "STRING", description: "P-value" }
            }
          }
        }
      }
    };

    const QUICK_PROMPTS = [
      "Summarize key findings",
      "Assess risk of bias",
      "List exclusion criteria",
      "Describe the intervention"
    ];

    // --- GLOBAL UTILS ---
    const cleanExtractedText = (text) => {
      if (!text) return "";
      return text.replace(/(\w)-\n(\w)/g, '$1$2').replace(/\n/g, ' ').replace(/\s+/g, ' ').trim();
    };

    /**
     * Convert PDF coordinates to canvas pixel coordinates
     * PDF coordinates: origin at bottom-left, y increases upward
     * Canvas coordinates: origin at top-left, y increases downward
     */
    const pdfToCanvasCoords = (pdfX, pdfY, pdfWidth, pdfHeight, viewport) => {
      // Apply viewport transformation
      const [a, b, c, d, e, f] = viewport.transform;

      // PDF coords to canvas coords using transformation matrix
      // For standard viewport: x' = scale * x, y' = height - (scale * y)
      const canvasX = pdfX * viewport.scale;
      const canvasY = viewport.height - (pdfY * viewport.scale);
      const canvasWidth = pdfWidth * viewport.scale;
      const canvasHeight = pdfHeight * viewport.scale;

      return {
        left: canvasX,
        top: canvasY - canvasHeight, // Adjust for height since y is bottom of rect in PDF
        width: canvasWidth,
        height: canvasHeight
      };
    };

    /**
     * Convert citation highlight from PDF space to canvas space
     */
    const convertCitationHighlight = (citation, viewport) => {
      return {
        ...citation,
        canvasRect: pdfToCanvasCoords(
          citation.x,
          citation.y,
          citation.width,
          citation.height,
          viewport
        )
      };
    };

    /**
     * Call Claude API with native citations enabled via Firebase Callable Function
     * Uses httpsCallable for automatic auth handling and type-safe serialization
     */
    const getFunctions = () => {
      // Get Firebase Functions instance (uses default region us-central1)
      return firebase.functions();
    };

    const callClaudeWithCitations = async (pdfText, positions = null, extractionPrompt = null) => {
      try {
        const functions = getFunctions();
        const extractCitations = functions.httpsCallable('extractCitations');

        // Call the callable function - auth token automatically included
        const result = await extractCitations({
          pdfText,
          positions,
          extractionPrompt
        });

        return result.data; // Callable functions return {data: ...}
      } catch (error) {
        // Firebase callable errors have code and message
        console.warn('Citation API error:', error.code, error.message);
        // Return null to allow fallback to Gemini
        return null;
      }
    };

    /**
     * Extract text with positions from PDF pages
     * Returns array of position objects for citation mapping
     */
    const extractPdfPositions = async (pdfDoc) => {
      const positions = [];
      let globalCharIndex = 0;

      for (let pageNum = 1; pageNum <= pdfDoc.numPages; pageNum++) {
        const page = await pdfDoc.getPage(pageNum);
        const textContent = await page.getTextContent();

        for (const item of textContent.items) {
          if (!item.str) continue;

          const text = item.str;
          const startChar = globalCharIndex;
          const endChar = globalCharIndex + text.length;

          positions.push({
            text,
            startChar,
            endChar,
            x: item.transform[4],
            y: item.transform[5],
            width: item.width || 0,
            height: item.height || 10,
            page: pageNum,
          });

          globalCharIndex = endChar + 1; // +1 for space separator
        }

        globalCharIndex += 2; // Page separator
      }

      return positions;
    };

    const callGemini = async (prompt, schema = null) => {
      const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;

      const payload = {
        contents: [{ parts: [{ text: prompt }] }],
      };

      if (schema) {
        payload.generationConfig = { responseMimeType: "application/json", responseSchema: schema };
      }

      const response = await fetch(apiUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });

      if (!response.ok) throw new Error("API Error");
      const result = await response.json();
      return result.candidates?.[0]?.content?.parts?.[0]?.text;
    };

    // --- COMPONENTS ---

    // Detailed Extraction Field Components
    const IndicationField = ({ data, onUpdate, onRemove, index }) => (
      <div className="dynamic-container">
        <h4>Indication {index + 1}</h4>
        <button className="remove-btn" onClick={onRemove}>Remove</button>
        <div className="grid-2col">
          <div className="form-group">
            <label>Sign/Symptom</label>
            <select
              value={data.sign}
              onChange={(e) => onUpdate('sign', e.target.value)}
              className="form-control"
            >
              <option value="">Select...</option>
              <option value="Drowsiness">Drowsiness</option>
              <option value="GCS_Drop">Drop in GCS</option>
              <option value="Imaging_Mass_Effect">Imaging signs of mass effect</option>
              <option value="Other">Other</option>
            </select>
          </div>
          <div className="form-group">
            <label>Count (N)</label>
            <input
              type="number"
              value={data.count}
              onChange={(e) => onUpdate('count', e.target.value)}
              className="form-control"
            />
          </div>
        </div>
      </div>
    );

    const InterventionField = ({ data, onUpdate, onRemove, index }) => (
      <div className="dynamic-container">
        <h4>Intervention Type {index + 1}</h4>
        <button className="remove-btn" onClick={onRemove}>Remove</button>
        <div className="form-group">
          <label>Surgical Type</label>
          <select
            value={data.type}
            onChange={(e) => onUpdate('type', e.target.value)}
            className="form-control"
          >
            <option value="">Select...</option>
            <option value="SDC_EVD">SDC + EVD</option>
            <option value="SDC_ALONE">SDC Alone</option>
            <option value="EVD_ALONE">EVD Alone</option>
          </select>
        </div>
        <div className="form-group">
          <label>Time To Surgery (Hours)</label>
          <input
            type="number"
            step="0.1"
            value={data.timeToSurgery}
            onChange={(e) => onUpdate('timeToSurgery', e.target.value)}
            className="form-control"
          />
        </div>
        <div className="form-group">
          <label>Duraplasty?</label>
          <select
            value={data.duraplasty}
            onChange={(e) => onUpdate('duraplasty', e.target.value)}
            className="form-control"
          >
            <option value="null">Unknown</option>
            <option value="true">Yes</option>
            <option value="false">No</option>
          </select>
        </div>
      </div>
    );

    const StudyArmField = ({ data, onUpdate, onRemove, index }) => (
      <div className="dynamic-container">
        <h4>Study Arm {index + 1}</h4>
        <button className="remove-btn" onClick={onRemove}>Remove</button>
        <div className="grid-2col">
          <div className="form-group">
            <label>Label</label>
            <input
              type="text"
              value={data.label}
              onChange={(e) => onUpdate('label', e.target.value)}
              className="form-control"
              placeholder="e.g., SDC Group, Control"
            />
          </div>
          <div className="form-group">
            <label>Sample Size (N)</label>
            <input
              type="number"
              value={data.sampleSize}
              onChange={(e) => onUpdate('sampleSize', e.target.value)}
              className="form-control"
            />
          </div>
        </div>
      </div>
    );

    const MortalityField = ({ data, onUpdate, onRemove, index, availableArms }) => (
      <div className="dynamic-container">
        <h4>Mortality Data Point {index + 1}</h4>
        <button className="remove-btn" onClick={onRemove}>Remove</button>
        <div className="grid-2col">
          <div className="form-group">
            <label>Arm</label>
            <select
              value={data.arm}
              onChange={(e) => onUpdate('arm', e.target.value)}
              className="form-control arm-selector"
            >
              <option value="">Select Arm...</option>
              {availableArms.map(arm => (
                <option key={arm.id} value={arm.label}>{arm.label}</option>
              ))}
            </select>
          </div>
          <div className="form-group">
            <label>Timepoint</label>
            <input
              type="text"
              value={data.timepoint}
              onChange={(e) => onUpdate('timepoint', e.target.value)}
              className="form-control"
              placeholder="e.g., 30 days, 90 days"
            />
          </div>
        </div>
        <div className="grid-2col">
          <div className="form-group">
            <label>Deaths (N)</label>
            <input
              type="number"
              value={data.deaths}
              onChange={(e) => onUpdate('deaths', e.target.value)}
              className="form-control"
            />
          </div>
          <div className="form-group">
            <label>Total (N)</label>
            <input
              type="number"
              value={data.total}
              onChange={(e) => onUpdate('total', e.target.value)}
              className="form-control"
            />
          </div>
        </div>
      </div>
    );

    const MRSField = ({ data, onUpdate, onRemove, index, availableArms }) => (
      <div className="dynamic-container">
        <h4>mRS Data Point {index + 1}</h4>
        <button className="remove-btn" onClick={onRemove}>Remove</button>
        <div className="grid-2col">
          <div className="form-group">
            <label>Arm</label>
            <select
              value={data.arm}
              onChange={(e) => onUpdate('arm', e.target.value)}
              className="form-control arm-selector"
            >
              <option value="">Select Arm...</option>
              {availableArms.map(arm => (
                <option key={arm.id} value={arm.label}>{arm.label}</option>
              ))}
            </select>
          </div>
          <div className="form-group">
            <label>Timepoint</label>
            <input
              type="text"
              value={data.timepoint}
              onChange={(e) => onUpdate('timepoint', e.target.value)}
              className="form-control"
              placeholder="e.g., 90 days, 6 months"
            />
          </div>
        </div>
        <h5>mRS Distribution (Counts for scores 0-6)</h5>
        <div className="grid-mrs">
          {[0, 1, 2, 3, 4, 5, 6].map(score => (
            <div key={score} className="form-group">
              <label>{score}</label>
              <input
                type="number"
                value={data.scores[score]}
                onChange={(e) => onUpdate(`score_${score}`, e.target.value)}
                className="form-control"
              />
            </div>
          ))}
        </div>
      </div>
    );

    const ComplicationField = ({ data, onUpdate, onRemove, index, availableArms }) => (
      <div className="dynamic-container">
        <h4>Complication {index + 1}</h4>
        <button className="remove-btn" onClick={onRemove}>Remove</button>
        <div className="grid-2col">
          <div className="form-group">
            <label>Description</label>
            <input
              type="text"
              value={data.description}
              onChange={(e) => onUpdate('description', e.target.value)}
              className="form-control"
              placeholder="e.g., Infection, Hemorrhage"
            />
          </div>
          <div className="form-group">
            <label>Arm</label>
            <select
              value={data.arm}
              onChange={(e) => onUpdate('arm', e.target.value)}
              className="form-control arm-selector"
            >
              <option value="">Select Arm...</option>
              {availableArms.map(arm => (
                <option key={arm.id} value={arm.label}>{arm.label}</option>
              ))}
            </select>
          </div>
        </div>
        <div className="form-group">
          <label>Count (N)</label>
          <input
            type="number"
            value={data.count}
            onChange={(e) => onUpdate('count', e.target.value)}
            className="form-control"
          />
        </div>
      </div>
    );

    const PredictorField = ({ data, onUpdate, onRemove, index }) => (
      <div className="dynamic-container">
        <h4>Predictor Analysis {index + 1}</h4>
        <button className="remove-btn" onClick={onRemove}>Remove</button>
        <div className="form-group">
          <label>Predictor Variable</label>
          <input
            type="text"
            value={data.variable}
            onChange={(e) => onUpdate('variable', e.target.value)}
            className="form-control"
            placeholder="e.g., Age, GCS, Hydrocephalus"
          />
        </div>
        <div className="grid-3col">
          <div className="form-group">
            <label>Effect Size (OR/HR)</label>
            <input
              type="number"
              step="0.01"
              value={data.effectSize}
              onChange={(e) => onUpdate('effectSize', e.target.value)}
              className="form-control"
            />
          </div>
          <div className="form-group">
            <label>95% CI (Lower)</label>
            <input
              type="number"
              step="0.01"
              value={data.ciLower}
              onChange={(e) => onUpdate('ciLower', e.target.value)}
              className="form-control"
            />
          </div>
          <div className="form-group">
            <label>95% CI (Upper)</label>
            <input
              type="number"
              step="0.01"
              value={data.ciUpper}
              onChange={(e) => onUpdate('ciUpper', e.target.value)}
              className="form-control"
            />
          </div>
        </div>
        <div className="form-group">
          <label>p-Value</label>
          <input
            type="number"
            step="0.001"
            value={data.pValue}
            onChange={(e) => onUpdate('pValue', e.target.value)}
            className="form-control"
          />
        </div>
      </div>
    );

    // Detailed Extraction Panel - Main container for all dynamic fields
    const DetailedExtractionPanel = ({
      indications, interventions, studyArms, mortalityData, mrsData, complications, predictors,
      onAddIndication, onAddIntervention, onAddArm, onAddMortality, onAddMRS, onAddComplication, onAddPredictor,
      onUpdateField, onRemoveField
    }) => {
      return (
        <div style={{ padding: '20px', overflowY: 'auto', height: '100%', background: '#f8f9fa' }}>
          <h2 style={{ marginBottom: '24px', color: '#2c3e50' }}>Detailed Extraction</h2>
          <p style={{ marginBottom: '32px', color: '#666', fontSize: '14px' }}>
            Capture comprehensive study data with dynamic fields for indications, interventions, study arms, outcomes, and statistical analyses.
          </p>

          {/* Study Arms Section (CRITICAL: Must come first for linked selectors) */}
          <div className="field-section">
            <h3> Study Arms</h3>
            <p className="field-section-description">
              Define treatment groups. These arms will automatically appear in mortality, mRS, and complication selectors.
            </p>
            <button className="add-field-btn" onClick={onAddArm}>
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <path d="M12 5v14m-7-7h14" />
              </svg>
              Add Study Arm
            </button>
            {studyArms.length === 0 ? (
              <div className="empty-state">Add your first study arm to enable arm-specific data collection</div>
            ) : (
              studyArms.map((arm, i) => (
                <StudyArmField
                  key={arm.id}
                  data={arm}
                  index={i}
                  onUpdate={(field, value) => onUpdateField('arm', arm.id, field, value)}
                  onRemove={() => onRemoveField('arm', arm.id)}
                />
              ))
            )}
          </div>

          {/* Indications Section */}
          <div className="field-section">
            <h3> Indications for Surgery</h3>
            <p className="field-section-description">Signs and symptoms that indicated need for surgical intervention.</p>
            <button className="add-field-btn" onClick={onAddIndication}>
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <path d="M12 5v14m-7-7h14" />
              </svg>
              Add Indication
            </button>
            {indications.length === 0 ? (
              <div className="empty-state">No indications added yet</div>
            ) : (
              indications.map((indication, i) => (
                <IndicationField
                  key={indication.id}
                  data={indication}
                  index={i}
                  onUpdate={(field, value) => onUpdateField('indication', indication.id, field, value)}
                  onRemove={() => onRemoveField('indication', indication.id)}
                />
              ))
            )}
          </div>

          {/* Interventions Section */}
          <div className="field-section">
            <h3> Interventions</h3>
            <p className="field-section-description">Surgical procedures and intervention details.</p>
            <button className="add-field-btn" onClick={onAddIntervention}>
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <path d="M12 5v14m-7-7h14" />
              </svg>
              Add Intervention
            </button>
            {interventions.length === 0 ? (
              <div className="empty-state">No interventions added yet</div>
            ) : (
              interventions.map((intervention, i) => (
                <InterventionField
                  key={intervention.id}
                  data={intervention}
                  index={i}
                  onUpdate={(field, value) => onUpdateField('intervention', intervention.id, field, value)}
                  onRemove={() => onRemoveField('intervention', intervention.id)}
                />
              ))
            )}
          </div>

          {/* Mortality Section */}
          <div className="field-section">
            <h3> Mortality Data</h3>
            <p className="field-section-description">Mortality outcomes by study arm and timepoint.</p>
            <button className="add-field-btn" onClick={onAddMortality}>
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <path d="M12 5v14m-7-7h14" />
              </svg>
              Add Mortality Data Point
            </button>
            {mortalityData.length === 0 ? (
              <div className="empty-state">No mortality data added yet. Add study arms first to enable arm selection.</div>
            ) : (
              mortalityData.map((mortality, i) => (
                <MortalityField
                  key={mortality.id}
                  data={mortality}
                  index={i}
                  availableArms={studyArms.filter(arm => arm.label.trim())}
                  onUpdate={(field, value) => onUpdateField('mortality', mortality.id, field, value)}
                  onRemove={() => onRemoveField('mortality', mortality.id)}
                />
              ))
            )}
          </div>

          {/* mRS Section */}
          <div className="field-section">
            <h3> mRS Distribution</h3>
            <p className="field-section-description">Modified Rankin Scale outcomes with full 0-6 score distribution.</p>
            <button className="add-field-btn" onClick={onAddMRS}>
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <path d="M12 5v14m-7-7h14" />
              </svg>
              Add mRS Data Point
            </button>
            {mrsData.length === 0 ? (
              <div className="empty-state">No mRS data added yet. Add study arms first to enable arm selection.</div>
            ) : (
              mrsData.map((mrs, i) => (
                <MRSField
                  key={mrs.id}
                  data={mrs}
                  index={i}
                  availableArms={studyArms.filter(arm => arm.label.trim())}
                  onUpdate={(field, value) => onUpdateField('mrs', mrs.id, field, value)}
                  onRemove={() => onRemoveField('mrs', mrs.id)}
                />
              ))
            )}
          </div>

          {/* Complications Section */}
          <div className="field-section">
            <h3> Complications</h3>
            <p className="field-section-description">Adverse events and complications by study arm.</p>
            <button className="add-field-btn" onClick={onAddComplication}>
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <path d="M12 5v14m-7-7h14" />
              </svg>
              Add Complication
            </button>
            {complications.length === 0 ? (
              <div className="empty-state">No complications added yet. Add study arms first to enable arm selection.</div>
            ) : (
              complications.map((complication, i) => (
                <ComplicationField
                  key={complication.id}
                  data={complication}
                  index={i}
                  availableArms={studyArms.filter(arm => arm.label.trim())}
                  onUpdate={(field, value) => onUpdateField('complication', complication.id, field, value)}
                  onRemove={() => onRemoveField('complication', complication.id)}
                />
              ))
            )}
          </div>

          {/* Predictors Section */}
          <div className="field-section">
            <h3> Predictor Analyses</h3>
            <p className="field-section-description">Statistical predictors with effect sizes and confidence intervals.</p>
            <button className="add-field-btn" onClick={onAddPredictor}>
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <path d="M12 5v14m-7-7h14" />
              </svg>
              Add Predictor
            </button>
            {predictors.length === 0 ? (
              <div className="empty-state">No predictors added yet</div>
            ) : (
              predictors.map((predictor, i) => (
                <PredictorField
                  key={predictor.id}
                  data={predictor}
                  index={i}
                  onUpdate={(field, value) => onUpdateField('predictor', predictor.id, field, value)}
                  onRemove={() => onRemoveField('predictor', predictor.id)}
                />
              ))
            )}
          </div>
        </div>
      );
    };

    // ========================================
    // TABLES PANEL - Extract tables from PDFs
    // ========================================
    const TablesPanel = ({ pdfDoc, pdfFile }) => {
      const [tables, setTables] = useState([]);
      const [isExtracting, setIsExtracting] = useState(false);

      const extractTables = async () => {
        if (!pdfFile) {
          alert('Please upload a PDF first');
          return;
        }

        setIsExtracting(true);
        try {
          // Convert PDF file to base64
          const reader = new FileReader();
          const pdfBase64 = await new Promise((resolve, reject) => {
            reader.onload = () => {
              // Extract base64 data (remove data:application/pdf;base64, prefix)
              const base64String = reader.result.split(',')[1];
              resolve(base64String);
            };
            reader.onerror = reject;
            reader.readAsDataURL(pdfFile);
          });

          // Try local server first (development), then Cloud Run
          const urls = [
            'http://localhost:5003/extract_tables',  // Local development server
            'https://extract-tables-5amidalpvq-uc.a.run.app'  // Cloud Run (requires IAM setup)
          ];

          let result = null;
          let lastError = null;

          for (const functionUrl of urls) {
            try {
              console.log('[extractTables] Trying:', functionUrl);
              const response = await fetch(functionUrl, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify({ pdf_base64: pdfBase64 })
              });

              if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
              }

              result = await response.json();
              console.log('[extractTables] Success from:', functionUrl);
              break;  // Success, exit loop
            } catch (err) {
              console.log('[extractTables] Failed:', functionUrl, err.message);
              lastError = err;
            }
          }

          if (!result) {
            throw lastError || new Error('All extraction endpoints failed');
          }

          if (result.success && result.tables) {
            // Transform extracted tables to include display data
            const transformedTables = result.tables.map((table, index) => ({
              id: index,
              page: table.page,
              table_index: table.table_index,
              headers: table.headers || [],
              rows: table.rows || [],
              raw: table.raw || [],
              rowCount: table.rows ? table.rows.length : 0,
              colCount: table.headers ? table.headers.length : 0
            }));
            setTables(transformedTables);
            // Expose tables for section-priority extraction
            window._extractedTables = transformedTables;
          } else {
            alert('No tables found in the PDF');
            setTables([]);
            window._extractedTables = [];
          }
        } catch (error) {
          console.error('Table extraction failed:', error);
          alert(`Failed to extract tables: ${error.message}`);
          setTables([]);
        } finally {
          setIsExtracting(false);
        }
      };

      return (
        <div style={{ padding: '20px', overflowY: 'auto', height: '100%' }}>
          <h2> Table Extraction</h2>
          <p style={{ color: '#666', marginBottom: '20px' }}>
            Extract and export tables from your PDF document.
          </p>

          <button
            onClick={extractTables}
            disabled={!pdfFile || isExtracting}
            style={{
              padding: '12px 24px',
              background: pdfFile ? '#4CAF50' : '#ccc',
              color: 'white',
              border: 'none',
              borderRadius: '4px',
              cursor: pdfFile ? 'pointer' : 'not-allowed',
              fontWeight: 600,
              marginBottom: '20px'
            }}
          >
            {isExtracting ? ' Extracting Tables...' : ' Extract Tables'}
          </button>

          {isExtracting && (
            <div style={{ padding: '20px', textAlign: 'center' }}>
              <div className="spinner" style={{ margin: '0 auto' }}></div>
              <p style={{ marginTop: '10px', color: '#666' }}>Analyzing PDF for tables...</p>
            </div>
          )}

          {tables.length > 0 && (
            <div>
              <h3>Found {tables.length} table(s)</h3>
              {tables.map(table => (
                <div key={table.id} style={{
                  background: '#f8f9fa',
                  border: '1px solid #dee2e6',
                  borderRadius: '8px',
                  padding: '16px',
                  marginBottom: '24px'
                }}>
                  <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '12px' }}>
                    <div>
                      <h4 style={{ margin: '0 0 8px 0' }}>
                        Table {table.table_index + 1} (Page {table.page})
                      </h4>
                      <p style={{ color: '#666', fontSize: '14px', margin: 0 }}>
                        {table.rowCount} rows  {table.colCount} columns
                      </p>
                    </div>
                    <button
                      onClick={() => {
                        // Convert table to CSV
                        const csvContent = [
                          table.headers.join(','),
                          ...table.rows.map(row => row.map(cell => `"${cell}"`).join(','))
                        ].join('\n');

                        // Create download link
                        const blob = new Blob([csvContent], { type: 'text/csv' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `table_page${table.page}_${table.table_index + 1}.csv`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                      }}
                      style={{
                        padding: '8px 16px',
                        background: '#007bff',
                        color: 'white',
                        border: 'none',
                        borderRadius: '4px',
                        cursor: 'pointer',
                        fontWeight: 500
                      }}
                    >
                       Export CSV
                    </button>
                  </div>

                  {/* Render actual table data */}
                  <div style={{ overflowX: 'auto', marginTop: '12px' }}>
                    <table style={{
                      width: '100%',
                      borderCollapse: 'collapse',
                      fontSize: '14px',
                      background: 'white'
                    }}>
                      <thead>
                        <tr style={{ background: '#e9ecef' }}>
                          {table.headers.map((header, i) => (
                            <th key={i} style={{
                              padding: '10px',
                              border: '1px solid #dee2e6',
                              textAlign: 'left',
                              fontWeight: 600,
                              whiteSpace: 'nowrap'
                            }}>
                              {header || `Column ${i + 1}`}
                            </th>
                          ))}
                        </tr>
                      </thead>
                      <tbody>
                        {table.rows.map((row, rowIndex) => (
                          <tr key={rowIndex} style={{
                            background: rowIndex % 2 === 0 ? 'white' : '#f8f9fa'
                          }}>
                            {row.map((cell, cellIndex) => (
                              <td key={cellIndex} style={{
                                padding: '8px 10px',
                                border: '1px solid #dee2e6',
                                whiteSpace: 'pre-wrap'
                              }}>
                                {cell || ''}
                              </td>
                            ))}
                          </tr>
                        ))}
                      </tbody>
                    </table>
                  </div>
                </div>
              ))}
            </div>
          )}

          {!pdfFile && (
            <div style={{
              padding: '40px',
              textAlign: 'center',
              background: '#f8f9fa',
              borderRadius: '8px',
              border: '2px dashed #dee2e6'
            }}>
              <p style={{ color: '#6c757d', fontSize: '16px' }}>
                Upload a PDF to extract tables
              </p>
            </div>
          )}
        </div>
      );
    };

    // ========================================
    // FIGURES PANEL - Extract figures/images from PDFs
    // ========================================
    const FiguresPanel = ({ pdfDoc, pdfFile }) => {
      const [figures, setFigures] = useState([]);
      const [isExtracting, setIsExtracting] = useState(false);
      const [transcriptions, setTranscriptions] = useState({}); // {figureId: "transcribed text"}
      const [transcribingId, setTranscribingId] = useState(null);

      // OCR: Transcribe a figure using Gemini Vision
      const transcribeFigure = async (figure) => {
        if (!figure.imageData) {
          alert('No image data available');
          return;
        }

        setTranscribingId(figure.id);
        try {
          // Extract base64 data (remove data:image/png;base64, prefix)
          const base64Data = figure.imageData.split(',')[1];

          // Call Gemini with vision capability
          const prompt = `Analyze this image from a medical research paper. Extract ALL text, numbers, and data visible in the image. If it's a table, preserve the structure. If it's a chart/graph, describe the data points and trends. Be thorough and precise.

Focus on:
1. All visible text (labels, titles, captions)
2. All numerical values
3. Table data (if present) - preserve row/column structure
4. Statistical information (p-values, confidence intervals, percentages)
5. Any figure/table numbering or references`;

          const response = await fetch(
            `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${GOOGLE_API_KEY}`,
            {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                contents: [{
                  parts: [
                    { text: prompt },
                    {
                      inline_data: {
                        mime_type: 'image/png',
                        data: base64Data
                      }
                    }
                  ]
                }]
              })
            }
          );

          const result = await response.json();
          const transcribedText = result.candidates?.[0]?.content?.parts?.[0]?.text || 'No text extracted';

          // Store transcription
          const newTranscriptions = {
            ...transcriptions,
            [figure.id]: transcribedText
          };
          setTranscriptions(newTranscriptions);
          // Expose figure transcriptions for section-priority extraction
          window._figureTranscriptions = newTranscriptions;

          // Also update the figure object
          setFigures(prev => prev.map(f =>
            f.id === figure.id ? { ...f, transcription: transcribedText } : f
          ));

        } catch (error) {
          console.error('Figure transcription failed:', error);
          alert('Failed to transcribe figure: ' + error.message);
        } finally {
          setTranscribingId(null);
        }
      };

      const extractFigures = async () => {
        if (!pdfFile) {
          alert('Please upload a PDF first');
          return;
        }

        setIsExtracting(true);
        try {
          // Convert PDF file to base64
          const reader = new FileReader();
          const pdfBase64 = await new Promise((resolve, reject) => {
            reader.onload = () => {
              const base64String = reader.result.split(',')[1];
              resolve(base64String);
            };
            reader.onerror = reject;
            reader.readAsDataURL(pdfFile);
          });

          // Try local server first (development), then Cloud Run
          const urls = [
            'http://localhost:5003/extract_figures',  // Local development server
            'https://extract-figures-5amidalpvq-uc.a.run.app'  // Cloud Run (requires IAM setup)
          ];

          let result = null;
          let lastError = null;

          for (const functionUrl of urls) {
            try {
              console.log('[extractFigures] Trying:', functionUrl);
              const response = await fetch(functionUrl, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify({ pdf_base64: pdfBase64 })
              });

              if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
              }

              result = await response.json();
              console.log('[extractFigures] Success from:', functionUrl);
              break;  // Success, exit loop
            } catch (err) {
              console.log('[extractFigures] Failed:', functionUrl, err.message);
              lastError = err;
            }
          }

          // If no result from either endpoint, throw the error (will trigger fallback)
          if (!result) {
            throw lastError || new Error('All extraction endpoints failed');
          }

          if (result.success && result.figures && result.figures.length > 0) {
            // Transform extracted figures to display format
            const extractedFigures = result.figures.map((fig, index) => ({
              id: index + 1,
              pageNum: fig.page,
              type: 'Extracted Image',
              caption: `Figure from Page ${fig.page}`,
              imageData: `data:image/png;base64,${fig.image_base64}`,
              bbox: fig.bbox,
              width: fig.width,
              height: fig.height
            }));
            setFigures(extractedFigures);
            console.log(`[extractFigures] Found ${extractedFigures.length} actual figures`);
          } else {
            // Fallback: If no embedded images found, render pages as snapshots
            console.log('[extractFigures] No embedded figures found, using page snapshots as fallback');
            const extractedFigures = [];

            for (let pageNum = 1; pageNum <= Math.min(pdfDoc.numPages, 10); pageNum++) {
              const page = await pdfDoc.getPage(pageNum);
              const viewport = page.getViewport({ scale: 1.5 });

              const canvas = document.createElement('canvas');
              const context = canvas.getContext('2d');
              canvas.height = viewport.height;
              canvas.width = viewport.width;

              await page.render({
                canvasContext: context,
                viewport: viewport
              }).promise;

              extractedFigures.push({
                id: pageNum,
                pageNum: pageNum,
                type: 'Page Snapshot',
                caption: `Page ${pageNum} (no embedded figures found)`,
                imageData: canvas.toDataURL('image/png')
              });
            }

            setFigures(extractedFigures);
          }
        } catch (error) {
          console.error('[extractFigures] Cloud Function failed:', error);
          // Fallback to page snapshots on error
          console.log('[extractFigures] Falling back to page snapshots...');
          try {
            const extractedFigures = [];
            for (let pageNum = 1; pageNum <= Math.min(pdfDoc.numPages, 10); pageNum++) {
              const page = await pdfDoc.getPage(pageNum);
              const viewport = page.getViewport({ scale: 1.5 });

              const canvas = document.createElement('canvas');
              const context = canvas.getContext('2d');
              canvas.height = viewport.height;
              canvas.width = viewport.width;

              await page.render({
                canvasContext: context,
                viewport: viewport
              }).promise;

              extractedFigures.push({
                id: pageNum,
                pageNum: pageNum,
                type: 'Page Snapshot (fallback)',
                caption: `Page ${pageNum}`,
                imageData: canvas.toDataURL('image/png')
              });
            }
            setFigures(extractedFigures);
          } catch (fallbackError) {
            console.error('[extractFigures] Fallback also failed:', fallbackError);
            alert('Figure extraction failed. See console for details.');
          }
        } finally {
          setIsExtracting(false);
        }
      };

      return (
        <div style={{ padding: '20px', overflowY: 'auto', height: '100%' }}>
          <h2> Figure Extraction</h2>
          <p style={{ color: '#666', marginBottom: '20px' }}>
            Extract figures, charts, and images from your PDF document.
          </p>

          <button
            onClick={extractFigures}
            disabled={!pdfFile || isExtracting}
            style={{
              padding: '12px 24px',
              background: pdfFile ? '#9C27B0' : '#ccc',
              color: 'white',
              border: 'none',
              borderRadius: '4px',
              cursor: pdfFile ? 'pointer' : 'not-allowed',
              fontWeight: 600,
              marginBottom: '20px'
            }}
          >
            {isExtracting ? ' Extracting Figures...' : ' Extract Figures'}
          </button>

          {isExtracting && (
            <div style={{ padding: '20px', textAlign: 'center' }}>
              <div className="spinner" style={{ margin: '0 auto' }}></div>
              <p style={{ marginTop: '10px', color: '#666' }}>Analyzing PDF for figures...</p>
            </div>
          )}

          {figures.length > 0 && (
            <div>
              <h3>Found {figures.length} figure(s)</h3>
              <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(300px, 1fr))', gap: '16px' }}>
                {figures.map(figure => (
                  <div key={figure.id} style={{
                    background: '#f8f9fa',
                    border: '1px solid #dee2e6',
                    borderRadius: '8px',
                    padding: '16px'
                  }}>
                    <div style={{
                      width: '100%',
                      maxHeight: '300px',
                      background: '#e9ecef',
                      borderRadius: '4px',
                      marginBottom: '12px',
                      overflow: 'hidden',
                      display: 'flex',
                      alignItems: 'center',
                      justifyContent: 'center'
                    }}>
                      {figure.imageData ? (
                        <img
                          src={figure.imageData}
                          alt={figure.caption}
                          style={{
                            maxWidth: '100%',
                            maxHeight: '300px',
                            objectFit: 'contain'
                          }}
                        />
                      ) : (
                        <span style={{ color: '#6c757d' }}> {figure.type}</span>
                      )}
                    </div>
                    <p style={{ fontWeight: 600, margin: '0 0 4px 0' }}>{figure.caption}</p>
                    <p style={{ color: '#666', fontSize: '14px', margin: '0 0 12px 0' }}>
                      Page {figure.pageNum}
                    </p>

                    {/* Button group */}
                    <div style={{ display: 'flex', gap: '8px', marginBottom: '12px' }}>
                      <button
                        onClick={() => {
                          const link = document.createElement('a');
                          link.download = `page_${figure.pageNum}.png`;
                          link.href = figure.imageData;
                          link.click();
                        }}
                        style={{
                          padding: '8px 12px',
                          background: '#9C27B0',
                          color: 'white',
                          border: 'none',
                          borderRadius: '4px',
                          cursor: 'pointer',
                          flex: 1,
                          fontSize: '13px'
                        }}>
                         Export
                      </button>
                      <button
                        onClick={() => transcribeFigure(figure)}
                        disabled={transcribingId === figure.id}
                        style={{
                          padding: '8px 12px',
                          background: transcribingId === figure.id ? '#ccc' : '#FF9800',
                          color: 'white',
                          border: 'none',
                          borderRadius: '4px',
                          cursor: transcribingId === figure.id ? 'not-allowed' : 'pointer',
                          flex: 1,
                          fontSize: '13px'
                        }}>
                        {transcribingId === figure.id ? ' Processing...' : ' OCR Transcribe'}
                      </button>
                    </div>

                    {/* Transcription display */}
                    {(figure.transcription || transcriptions[figure.id]) && (
                      <div style={{
                        background: '#fff8e1',
                        border: '1px solid #ffcc02',
                        borderRadius: '4px',
                        padding: '10px',
                        fontSize: '12px',
                        maxHeight: '150px',
                        overflowY: 'auto',
                        whiteSpace: 'pre-wrap'
                      }}>
                        <strong style={{ color: '#FF9800', display: 'block', marginBottom: '6px' }}>
                           Transcription:
                        </strong>
                        {figure.transcription || transcriptions[figure.id]}
                      </div>
                    )}
                  </div>
                ))}
              </div>
            </div>
          )}

          {!pdfFile && (
            <div style={{
              padding: '40px',
              textAlign: 'center',
              background: '#f8f9fa',
              borderRadius: '8px',
              border: '2px dashed #dee2e6'
            }}>
              <p style={{ color: '#6c757d', fontSize: '16px' }}>
                Upload a PDF to extract figures
              </p>
            </div>
          )}
        </div>
      );
    };

    function App() {
      // PDF State
      const [pdfFile, setPdfFile] = useState(null);
      const [pdfDoc, setPdfDoc] = useState(null);
      const [pageNum, setPageNum] = useState(1);
      const [numPages, setNumPages] = useState(0);
      const [pageOneText, setPageOneText] = useState('');

      // Available PDFs from server
      const [availablePdfs, setAvailablePdfs] = useState([]);

      // Load PDF manifest on mount
      useEffect(() => {
        fetch('/pdf/pdfs.json')
          .then(res => res.json())
          .then(data => setAvailablePdfs(data.pdfs || []))
          .catch(err => console.log('No PDF manifest found:', err));
      }, []);

      // Load PDF from server by filename
      const loadPdfFromServer = async (filename) => {
        if (!filename) return;
        try {
          const response = await fetch(`/pdf/${filename}`);
          const blob = await response.blob();
          const file = new File([blob], filename, { type: 'application/pdf' });
          handleFileUpload(file);
        } catch (err) {
          console.error('Failed to load PDF:', err);
          showToast('Failed to load PDF from server', 'error');
        }
      };

      // Extraction State
      const [highlights, setHighlights] = useState([]);
      const [currentField, setCurrentField] = useState('');
      const [selectionMode, setSelectionMode] = useState(false);
      const [aiFilledFields, setAiFilledFields] = useState(new Set());

      // Citation State (from Claude Native Citations)
      const [citations, setCitations] = useState([]);
      const [activeCitation, setActiveCitation] = useState(null);
      const [citationHighlights, setCitationHighlights] = useState([]);

      // Firebase State
      const [user, setUser] = useState(null);
      const [saving, setSaving] = useState(false);

      const [extractedData, setExtractedData] = useState({
        study_id: '', authors: '', year: '', title: '',
        population: { sample_size: '', mean_age: '', diagnosis: 'Space-occupying cerebellar infarction', inclusion_criteria: '' },
        intervention: { procedure: '', timing_hours: '', technique: '', additional_details: '' },
        comparator: '',
        outcomes: { mortality: '', mRS_favorable: '', complications: '', length_of_stay: '' },
        timing: { follow_up_duration: '' },
        study_design: '', newcastle_ottawa_score: ''
      });

      // UI State
      const [toast, setToast] = useState(null);
      const [isLoading, setIsLoading] = useState(false);
      const [activeTab, setActiveTab] = useState('extract'); // 'extract', 'chat', 'review', or 'detailed'
      const [chatMessages, setChatMessages] = useState([]); // Array of {role, text}

      // Review Panel State (Human-in-the-Loop AI verification)
      const [aiExtractedData, setAiExtractedData] = useState(null); // Data from Genkit extraction
      const [verifiedFields, setVerifiedFields] = useState({}); // { fieldPath: 'verified' | 'flagged' }
      const [isExtracting, setIsExtracting] = useState(false);

      // Detailed Extraction State (7 dynamic field types)
      const [indications, setIndications] = useState([]);
      const [interventions, setInterventions] = useState([]);
      const [studyArms, setStudyArms] = useState([]);
      const [mortalityData, setMortalityData] = useState([]);
      const [mrsData, setMrsData] = useState([]);
      const [complications, setComplications] = useState([]);
      const [predictors, setPredictors] = useState([]);

      // Counters for generating unique IDs
      const counterRef = useRef({
        indication: 0,
        intervention: 0,
        arm: 0,
        mortality: 0,
        mrs: 0,
        complication: 0,
        predictor: 0
      });

      const showToast = (message, type = 'success') => {
        setToast({ message, type });
        setTimeout(() => setToast(null), 3000);
      };

      // --- DYNAMIC FIELD MANAGEMENT ---
      // Add field handlers
      const addIndication = () => {
        const id = counterRef.current.indication++;
        setIndications(prev => [...prev, {
          id,
          sign: '',
          count: ''
        }]);
      };

      const addIntervention = () => {
        const id = counterRef.current.intervention++;
        setInterventions(prev => [...prev, {
          id,
          type: '',
          timeToSurgery: '',
          duraplasty: 'null'
        }]);
      };

      const addStudyArm = () => {
        const id = counterRef.current.arm++;
        setStudyArms(prev => [...prev, {
          id,
          label: '',
          sampleSize: ''
        }]);
      };

      const addMortality = () => {
        const id = counterRef.current.mortality++;
        setMortalityData(prev => [...prev, {
          id,
          arm: '',
          timepoint: '',
          deaths: '',
          total: ''
        }]);
      };

      const addMRS = () => {
        const id = counterRef.current.mrs++;
        setMrsData(prev => [...prev, {
          id,
          arm: '',
          timepoint: '',
          scores: { 0: '', 1: '', 2: '', 3: '', 4: '', 5: '', 6: '' }
        }]);
      };

      const addComplication = () => {
        const id = counterRef.current.complication++;
        setComplications(prev => [...prev, {
          id,
          description: '',
          arm: '',
          count: ''
        }]);
      };

      const addPredictor = () => {
        const id = counterRef.current.predictor++;
        setPredictors(prev => [...prev, {
          id,
          variable: '',
          effectSize: '',
          ciLower: '',
          ciUpper: '',
          pValue: ''
        }]);
      };

      // Remove field handlers
      const removeField = (type, id) => {
        switch (type) {
          case 'indication':
            setIndications(prev => prev.filter(item => item.id !== id));
            break;
          case 'intervention':
            setInterventions(prev => prev.filter(item => item.id !== id));
            break;
          case 'arm':
            setStudyArms(prev => prev.filter(item => item.id !== id));
            break;
          case 'mortality':
            setMortalityData(prev => prev.filter(item => item.id !== id));
            break;
          case 'mrs':
            setMrsData(prev => prev.filter(item => item.id !== id));
            break;
          case 'complication':
            setComplications(prev => prev.filter(item => item.id !== id));
            break;
          case 'predictor':
            setPredictors(prev => prev.filter(item => item.id !== id));
            break;
        }
      };

      // Update field value handlers
      const updateField = (type, id, field, value) => {
        switch (type) {
          case 'indication':
            setIndications(prev => prev.map(item =>
              item.id === id ? { ...item, [field]: value } : item
            ));
            break;
          case 'intervention':
            setInterventions(prev => prev.map(item =>
              item.id === id ? { ...item, [field]: value } : item
            ));
            break;
          case 'arm':
            setStudyArms(prev => prev.map(item =>
              item.id === id ? { ...item, [field]: value } : item
            ));
            break;
          case 'mortality':
            setMortalityData(prev => prev.map(item =>
              item.id === id ? { ...item, [field]: value } : item
            ));
            break;
          case 'mrs':
            if (field.startsWith('score_')) {
              const scoreNum = field.split('_')[1];
              setMrsData(prev => prev.map(item =>
                item.id === id ? {
                  ...item,
                  scores: { ...item.scores, [scoreNum]: value }
                } : item
              ));
            } else {
              setMrsData(prev => prev.map(item =>
                item.id === id ? { ...item, [field]: value } : item
              ));
            }
            break;
          case 'complication':
            setComplications(prev => prev.map(item =>
              item.id === id ? { ...item, [field]: value } : item
            ));
            break;
          case 'predictor':
            setPredictors(prev => prev.map(item =>
              item.id === id ? { ...item, [field]: value } : item
            ));
            break;
        }
      };

      // --- CITATION JUMP FEATURE ---
      // State for persistent citation highlights (separate from manual highlights)
      const [citationMarkers, setCitationMarkers] = useState([]);

      // Jump to citation in PDF and highlight the source text
      // fieldName: optional label to show in tooltip (e.g., "Mortality Rate", "Sample Size")
      const jumpToCitation = async (sourceText, fieldName = null) => {
        console.log('[jumpToCitation] Called with:', { sourceText, fieldName, hasPdfDoc: !!pdfDoc });

        if (!pdfDoc || !sourceText) {
          showToast("No PDF loaded or no source text", "error");
          return;
        }

        // Clean the search text
        const searchText = sourceText.trim().substring(0, 100); // Use first 100 chars
        console.log('[jumpToCitation] Searching for:', searchText);

        try {
          // Search through all pages for the text
          for (let pageIdx = 1; pageIdx <= pdfDoc.numPages; pageIdx++) {
            const page = await pdfDoc.getPage(pageIdx);
            const textContent = await page.getTextContent();
            const pageText = textContent.items.map(item => item.str).join(' ');

            // Log first page for debugging
            if (pageIdx === 1) {
              console.log('[jumpToCitation] Page 1 text (first 200):', pageText.substring(0, 200));
            }

            // Use fuzzysort if available, otherwise simple includes
            let found = false;
            let matchScore = 0;

            if (window.fuzzysort) {
              const result = fuzzysort.single(searchText, pageText);
              console.log('[jumpToCitation] Fuzzysort result for page', pageIdx, ':', result?.score);
              if (result && result.score > -50000) { // Reasonable match threshold
                found = true;
                matchScore = result.score;
              }
            } else {
              // Fallback to simple substring match
              found = pageText.toLowerCase().includes(searchText.toLowerCase().substring(0, 50));
              console.log('[jumpToCitation] Simple search for page', pageIdx, ':', found);
            }

            if (found) {
              // Jump to the page
              setPageNum(pageIdx);
              console.log('[jumpToCitation] Found on page', pageIdx, '- searching for item position...');

              // Find approximate position of the text
              let foundItem = null;
              let foundIndex = -1;
              const searchLower = searchText.toLowerCase();

              // Try exact match first, then progressively shorter substrings
              const searchTerms = [
                searchLower.substring(0, 20),
                searchLower.substring(0, 10),
                searchLower.substring(0, 6),
                searchLower.split(' ')[0] // First word
              ].filter(s => s.length >= 3);

              for (const term of searchTerms) {
                for (let i = 0; i < textContent.items.length; i++) {
                  const item = textContent.items[i];
                  if (item.str.toLowerCase().includes(term)) {
                    foundItem = item;
                    foundIndex = i;
                    console.log('[jumpToCitation] Found item:', item.str, 'using term:', term);
                    break;
                  }
                }
                if (foundItem) break;
              }

              // If still not found, use first item with transform as fallback
              if (!foundItem) {
                for (let i = 0; i < textContent.items.length; i++) {
                  if (textContent.items[i].transform) {
                    foundItem = textContent.items[i];
                    foundIndex = i;
                    console.log('[jumpToCitation] Using fallback item:', foundItem.str);
                    break;
                  }
                }
              }

              if (foundItem && foundItem.transform) {
                // Create persistent highlight with tooltip info
                const viewport = page.getViewport({ scale: 1.5 });
                const [,, , , tx, ty] = foundItem.transform;
                const highlightId = Date.now();

                const citationHighlight = {
                  id: highlightId,
                  page: pageIdx,
                  field: fieldName || 'Citation',
                  rect: {
                    x: tx * viewport.scale,
                    y: viewport.height - (ty * viewport.scale) - 20,
                    width: Math.min(foundItem.width * viewport.scale * 3, 400),
                    height: 30
                  },
                  text: searchText.substring(0, 80),
                  tooltipText: fieldName
                    ? `${fieldName}: "${searchText.substring(0, 50)}..."`
                    : `"${searchText.substring(0, 60)}..."`,
                  isYellow: true, // Start with yellow
                  persistent: false
                };

                // Add to citation markers
                setCitationMarkers(prev => [...prev, citationHighlight]);

                // After 3 seconds, transition to persistent border (not remove)
                setTimeout(() => {
                  setCitationMarkers(prev => prev.map(h =>
                    h.id === highlightId
                      ? { ...h, isYellow: false, persistent: true }
                      : h
                  ));
                }, 3000);

                showToast(` Found "${fieldName || 'citation'}" on page ${pageIdx}`, "success");
              } else {
                showToast(` Found on page ${pageIdx} (no position data)`, "success");
              }

              return; // Found, stop searching
            }
          }

          // Not found on any page
          showToast("Citation text not found in PDF", "error");
        } catch (error) {
          console.error("Citation jump failed:", error);
          showToast("Failed to locate citation", "error");
        }
      };

      // Clear all citation markers
      const clearCitationMarkers = () => {
        setCitationMarkers([]);
      };

      // Make jumpToCitation available globally for citation buttons
      window.jumpToCitation = jumpToCitation;
      window.clearCitationMarkers = clearCitationMarkers;

      // --- FIREBASE AUTH ---
      const signInWithGoogle = async () => {
        const provider = new firebase.auth.GoogleAuthProvider();
        try {
          await auth.signInWithPopup(provider);
          analytics.logEvent('login', { method: 'google' });
          showToast("Signed in successfully!");
        } catch (error) {
          console.error("Auth Error:", error);
          showToast("Sign in failed", "error");
        }
      };

      const signOut = () => {
        auth.signOut();
        showToast("Signed out");
      };

      useEffect(() => {
        if (!auth) return;
        const unsubscribe = auth.onAuthStateChanged(user => {
          setUser(user);
          if (!user) {
            // Optional: Auto-signin anonymously if you want to allow guest access
            // auth.signInAnonymously().catch(console.error);
          }
        });
        return unsubscribe;
      }, []);

      // --- FIREBASE SYNC ---
      // 1. Load initial data
      useEffect(() => {
        if (!user || !db) return;
        const docRef = db.collection('artifacts').doc(appId).collection('users').doc(user.uid).collection('data').doc('current_extraction');

        // Initial Load
        docRef.get().then(doc => {
          if (doc.exists) {
            const data = doc.data();
            if (data.extractedData) {
              setExtractedData(data.extractedData);
              setAiFilledFields(new Set(data.aiFilledFields || []));
              setHighlights(data.highlights || []);
              showToast("Cloud data loaded");
            }
          }
        }).catch(console.error);

        return () => { };
      }, [user]);

      // 2. Auto-save on change (Debounced)
      useEffect(() => {
        if (!user || !db) return;
        const docRef = db.collection('artifacts').doc(appId).collection('users').doc(user.uid).collection('data').doc('current_extraction');

        setSaving(true);
        const handler = setTimeout(() => {
          docRef.set({
            extractedData,
            highlights,
            aiFilledFields: Array.from(aiFilledFields),
            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
          }, { merge: true }).then(() => {
            setSaving(false);
          }).catch(err => {
            console.error("Save failed", err);
            setSaving(false);
          });
        }, 1000);

        return () => clearTimeout(handler);
      }, [extractedData, highlights, user, aiFilledFields]);


      const handleFileUpload = async (file) => {
        if (!file) return;
        setIsLoading(true);
        const reader = new FileReader();
        reader.onload = async (e) => {
          try {
            const arrayBuffer = e.target.result;
            setPdfFile(file);  // Store the File object, not just the filename
            setPdfDoc(null);
            setChatMessages([{ role: 'system', text: 'Document loaded. You can now chat with the abstract.' }]);

            const loadingTask = pdfjsLib.getDocument({ data: arrayBuffer });
            const pdf = await loadingTask.promise;
            setPdfDoc(pdf);
            setNumPages(pdf.numPages);
            setPageNum(1);

            try {
              const page = await pdf.getPage(1);
              const textContent = await page.getTextContent();
              const pageText = textContent.items.map(item => item.str).join(' ');
              setPageOneText(pageText);
            } catch (err) { console.error("Text extraction warning", err); }

            showToast("PDF loaded successfully");
            analytics.logEvent('pdf_uploaded', { file_name: file.name, num_pages: pdf.numPages });
          } catch (error) {
            showToast("Error loading PDF", 'error');
            console.error(error);
          } finally {
            setIsLoading(false);
          }
        };
        reader.readAsArrayBuffer(file);
      };

      const updateFormField = (path, value, isAi = false) => {
        const keys = path.split('.');
        setExtractedData(prev => {
          const next = JSON.parse(JSON.stringify(prev));
          let current = next;
          for (let i = 0; i < keys.length - 1; i++) current = current[keys[i]];
          current[keys[keys.length - 1]] = value;
          return next;
        });

        if (isAi) {
          setAiFilledFields(prev => new Set(prev).add(path));
        } else {
          const newSet = new Set(aiFilledFields);
          newSet.delete(path);
          setAiFilledFields(newSet);
        }
      };

      // --- FEATURE 0: CLAUDE CITATION EXTRACTION ---
      const handleClaudeCitationExtract = async () => {
        if (!pdfDoc) return showToast("No PDF loaded", "error");
        setIsLoading(true);

        try {
          // Extract full text with positions
          const positions = await extractPdfPositions(pdfDoc);
          const fullText = positions.map(p => p.text).join(' ');

          showToast("Extracting with Claude citations...");

          const result = await callClaudeWithCitations(fullText, positions);

          if (result && result.success) {
            // Set citations for display
            setCitations(result.citations || []);
            setCitationHighlights(result.citations || []);

            showToast(` Found ${result.citations?.length || 0} verified citations!`);
            analytics.logEvent('claude_citation_extraction', { citationCount: result.citations?.length || 0 });
          } else {
            showToast("Citation extraction unavailable, using Gemini fallback", "error");
            // Fall back to Gemini
            await handleAiAutofill();
          }
        } catch (e) {
          console.error('Citation extraction error:', e);
          showToast("Citation extraction failed", "error");
        } finally {
          setIsLoading(false);
        }
      };

      // --- SECTION-PRIORITY EXTRACTION HELPER ---
      // Extract text from specific sections of the PDF with priority order:
      // 1. Methods + Results (primary sources)
      // 2. Tables (extracted data)
      // 3. Figures (OCR transcriptions)
      // 4. Abstract (fallback only)
      const extractPrioritizedContent = async () => {
        if (!pdfDoc) return { content: '', sources: [] };

        const sources = [];
        let fullText = '';

        // Extract text from ALL pages (increased limit from 20 to 50)
        const pagesToExtract = Math.min(pdfDoc.numPages, 50);
        console.log(`[extractPrioritizedContent] Extracting from ${pagesToExtract} pages (total: ${pdfDoc.numPages})`);

        for (let pageIdx = 1; pageIdx <= pagesToExtract; pageIdx++) {
          try {
            const page = await pdfDoc.getPage(pageIdx);
            const textContent = await page.getTextContent();
            const pageText = textContent.items.map(item => item.str).join(' ');
            fullText += `\n--- PAGE ${pageIdx} ---\n${pageText}`;
          } catch (e) {
            console.warn(`Failed to extract page ${pageIdx}:`, e);
          }
        }
        console.log(`[extractPrioritizedContent] Extracted ${fullText.length} chars from ${pagesToExtract} pages`);

        // Detect sections using common headers
        const sections = {
          methods: '',
          results: '',
          abstract: '',
          discussion: ''
        };

        // Simple section detection (case-insensitive)
        const methodsMatch = fullText.match(/(?:methods|materials and methods|patients and methods|study design)[\s\S]*?(?=results|discussion|conclusion|references|$)/i);
        const resultsMatch = fullText.match(/(?:results)[\s\S]*?(?=discussion|conclusion|references|$)/i);
        const abstractMatch = fullText.match(/(?:abstract|background|objective)[\s\S]*?(?=introduction|methods|materials|$)/i);

        if (methodsMatch) {
          sections.methods = methodsMatch[0].substring(0, 5000); // Limit length
          sources.push('Methods');
        }
        if (resultsMatch) {
          sections.results = resultsMatch[0].substring(0, 5000);
          sources.push('Results');
        }
        if (abstractMatch) {
          sections.abstract = abstractMatch[0].substring(0, 2000);
        }

        // Build prioritized content (Methods + Results first, Abstract as fallback)
        let prioritizedContent = '';

        if (sections.methods || sections.results) {
          prioritizedContent += '=== PRIMARY SOURCES (Methods & Results) ===\n';
          if (sections.methods) prioritizedContent += `\n[METHODS SECTION]\n${sections.methods}\n`;
          if (sections.results) prioritizedContent += `\n[RESULTS SECTION]\n${sections.results}\n`;
        }

        // Add table data if available (from TablesPanel state - we'll reference via window)
        if (window._extractedTables && window._extractedTables.length > 0) {
          prioritizedContent += '\n=== EXTRACTED TABLES ===\n';
          window._extractedTables.forEach((table, idx) => {
            prioritizedContent += `\n[Table ${idx + 1} - Page ${table.page}]\n`;
            if (table.headers) prioritizedContent += `Headers: ${table.headers.join(' | ')}\n`;
            if (table.rows) {
              table.rows.slice(0, 10).forEach(row => { // Limit rows
                prioritizedContent += `${row.join(' | ')}\n`;
              });
            }
          });
          sources.push('Tables');
        }

        // Add figure transcriptions if available
        if (window._figureTranscriptions) {
          const transcriptions = Object.values(window._figureTranscriptions).filter(t => t);
          if (transcriptions.length > 0) {
            prioritizedContent += '\n=== FIGURE TRANSCRIPTIONS (OCR) ===\n';
            transcriptions.forEach((t, idx) => {
              prioritizedContent += `\n[Figure ${idx + 1}]\n${t.substring(0, 1500)}\n`;
            });
            sources.push('Figures');
          }
        }

        // Only use Abstract as fallback if no Methods/Results found
        if (!sections.methods && !sections.results) {
          prioritizedContent += '\n=== ABSTRACT (Fallback) ===\n';
          prioritizedContent += sections.abstract || pageOneText || '';
          sources.push('Abstract (fallback)');
        }

        return { content: prioritizedContent.substring(0, 15000), sources };
      };

      // --- FEATURE 1: AUTO-FILL ENTIRE FORM ---
      const handleAiAutofill = async () => {
        if (!pdfDoc && !pageOneText) return showToast("No PDF loaded", "error");
        setIsLoading(true);

        // Extract prioritized content from Methods/Results/Tables/Figures
        const { content: prioritizedContent, sources } = await extractPrioritizedContent();
        const textToUse = prioritizedContent || pageOneText;

        if (!textToUse) {
          setIsLoading(false);
          return showToast("No text available for extraction", "error");
        }

        showToast(` Extracting from: ${sources.join(', ')}`, "success");

        const systemPrompt = `You are an expert systematic reviewer. Extract data from this medical study into the exact JSON structure provided.

IMPORTANT SOURCE PRIORITY:
- Data from Methods/Results sections is most reliable
- Data from Tables is precise - use exact numbers
- Data from Figures (OCR) may have transcription errors - verify if possible
- Abstract data is summary only - use as fallback

Be precise. If data is missing, use empty strings. Return ONLY valid JSON.

Study Content:
${textToUse}`;

        try {
          const jsonText = await callGemini(systemPrompt, GEMINI_SCHEMA);
          if (!jsonText) throw new Error("No data returned");

          const aiData = JSON.parse(jsonText);
          const newAiFields = new Set(aiFilledFields);

          setExtractedData(prev => {
            const next = JSON.parse(JSON.stringify(prev));

            const safeUpdate = (obj, targetObj, prefix) => {
              Object.keys(obj).forEach(k => {
                if (typeof obj[k] === 'object' && obj[k] !== null) {
                  safeUpdate(obj[k], targetObj[k], prefix ? `${prefix}.${k}` : k);
                } else if (obj[k] && targetObj.hasOwnProperty(k)) {
                  targetObj[k] = obj[k];
                  newAiFields.add(prefix ? `${prefix}.${k}` : k);
                }
              });
            }

            // Map specific top level fields manually to be safe
            if (aiData.study_id) { next.study_id = aiData.study_id; newAiFields.add('study_id'); }
            if (aiData.authors) { next.authors = aiData.authors; newAiFields.add('authors'); }
            if (aiData.year) { next.year = aiData.year; newAiFields.add('year'); }
            if (aiData.title) { next.title = aiData.title; newAiFields.add('title'); }
            if (aiData.study_design) { next.study_design = aiData.study_design; newAiFields.add('study_design'); }

            // Map nested
            if (aiData.population) safeUpdate(aiData.population, next.population, 'population');
            if (aiData.intervention) safeUpdate(aiData.intervention, next.intervention, 'intervention');
            if (aiData.outcomes) safeUpdate(aiData.outcomes, next.outcomes, 'outcomes');

            return next;
          });

          // Populate dynamic field arrays from AI extraction
          if (aiData.studyArms && Array.isArray(aiData.studyArms)) {
            const newArms = aiData.studyArms
              .filter(arm => arm.label) // Only add if has label
              .map(arm => ({
                id: counterRef.current.arm++,
                label: arm.label || '',
                sampleSize: arm.sampleSize || ''
              }));
            if (newArms.length > 0) {
              setStudyArms(newArms);
              newAiFields.add('studyArms');
            }
          }

          if (aiData.indications && Array.isArray(aiData.indications)) {
            const newIndications = aiData.indications
              .filter(ind => ind.sign) // Only add if has sign
              .map(ind => ({
                id: counterRef.current.indication++,
                sign: ind.sign || '',
                count: ind.count || ''
              }));
            if (newIndications.length > 0) {
              setIndications(newIndications);
              newAiFields.add('indications');
            }
          }

          if (aiData.interventions && Array.isArray(aiData.interventions)) {
            const newInterventions = aiData.interventions
              .filter(int => int.type) // Only add if has type
              .map(int => ({
                id: counterRef.current.intervention++,
                type: int.type || '',
                timeToSurgery: int.timeToSurgery || '',
                duraplasty: int.duraplasty || 'null'
              }));
            if (newInterventions.length > 0) {
              setInterventions(newInterventions);
              newAiFields.add('interventions');
            }
          }

          if (aiData.mortalities && Array.isArray(aiData.mortalities)) {
            const newMortalities = aiData.mortalities
              .filter(mort => mort.timepoint || mort.deaths) // Only add if has data
              .map(mort => ({
                id: counterRef.current.mortality++,
                arm: mort.arm || '',
                timepoint: mort.timepoint || '',
                deaths: mort.deaths || '',
                total: mort.total || ''
              }));
            if (newMortalities.length > 0) {
              setMortalityData(newMortalities);
              newAiFields.add('mortalities');
            }
          }

          if (aiData.mrsScores && Array.isArray(aiData.mrsScores)) {
            const newMrsScores = aiData.mrsScores
              .filter(mrs => mrs.arm || mrs.timepoint) // Only add if has identifier
              .map(mrs => ({
                id: counterRef.current.mrs++,
                arm: mrs.arm || '',
                timepoint: mrs.timepoint || '',
                scores: {
                  0: mrs.scores?.['0'] || '',
                  1: mrs.scores?.['1'] || '',
                  2: mrs.scores?.['2'] || '',
                  3: mrs.scores?.['3'] || '',
                  4: mrs.scores?.['4'] || '',
                  5: mrs.scores?.['5'] || '',
                  6: mrs.scores?.['6'] || ''
                }
              }));
            if (newMrsScores.length > 0) {
              setMrsData(newMrsScores);
              newAiFields.add('mrsScores');
            }
          }

          if (aiData.complications && Array.isArray(aiData.complications)) {
            const newComplications = aiData.complications
              .filter(comp => comp.description) // Only add if has description
              .map(comp => ({
                id: counterRef.current.complication++,
                description: comp.description || '',
                arm: comp.arm || '',
                count: comp.count || ''
              }));
            if (newComplications.length > 0) {
              setComplications(newComplications);
              newAiFields.add('complications');
            }
          }

          if (aiData.predictors && Array.isArray(aiData.predictors)) {
            const newPredictors = aiData.predictors
              .filter(pred => pred.variable) // Only add if has variable name
              .map(pred => ({
                id: counterRef.current.predictor++,
                variable: pred.variable || '',
                effectSize: pred.effectSize || '',
                ciLower: pred.ciLower || '',
                ciUpper: pred.ciUpper || '',
                pValue: pred.pValue || ''
              }));
            if (newPredictors.length > 0) {
              setPredictors(newPredictors);
              newAiFields.add('predictors');
            }
          }

          setAiFilledFields(newAiFields);
          showToast(` Data extracted from ${sources.join(', ') || 'PDF'}!`);
          analytics.logEvent('ai_extraction_completed', { sources });
        } catch (e) {
          console.error(e);
          showToast("AI Extraction failed", "error");
        } finally {
          setIsLoading(false);
        }
      };

      // --- FEATURE 2: SMART FIELD SUGGEST ---
      const handleSmartSuggest = async (fieldLabel, path) => {
        if (!pageOneText) return showToast("No text available", "error");

        const prompt = `Context: ${pageOneText}
          
          Task: Identify and extract the "${fieldLabel}" from the medical study abstract above.
          Return ONLY the extracted value as a plain text string. Do not include label names or markdown. 
          If not found, return "Not found".`;

        try {
          const result = await callGemini(prompt);
          if (result && !result.toLowerCase().includes("not found")) {
            updateFormField(path, result.trim(), true);
            showToast(` Found ${fieldLabel}`);
          } else {
            showToast(`Could not find ${fieldLabel}`, "error");
          }
        } catch (e) {
          console.error(e);
          showToast("Suggestion failed", "error");
        }
      };

      // --- FEATURE 3: CHAT ASSISTANT ---
      const handleSendMessage = async (text) => {
        if (!text.trim()) return;

        const newMessage = { role: 'user', text };
        setChatMessages(prev => [...prev, newMessage]);

        if (!pageOneText) {
          setChatMessages(prev => [...prev, { role: 'assistant', text: 'Please upload a PDF with extractable text first.' }]);
          return;
        }

        const prompt = `Context (Abstract of a medical study):
          ${pageOneText}
          
          User Question: ${text}
          
          Answer as a helpful medical research assistant. Keep it concise and grounded in the context provided.`;

        try {
          const response = await callGemini(prompt);
          setChatMessages(prev => [...prev, { role: 'assistant', text: response }]);
        } catch (e) {
          setChatMessages(prev => [...prev, { role: 'assistant', text: 'Sorry, I encountered an error processing your request.' }]);
        }
      };

      // --- FEATURE 4: QUALITY CHECK ---
      const handleQualityCheck = async () => {
        if (!pageOneText) return showToast("No text available", "error");
        setIsLoading(true);

        const prompt = `Context: ${pageOneText}
          
          Task: Evaluate the risk of bias and quality of this study based on the abstract. 
          1. Identify the study design (e.g. RCT, Cohort).
          2. Estimate a Newcastle-Ottawa Score (0-9) if observational, or Jadad Score (0-5) if RCT.
          3. Return a short 1-sentence reasoning.
          
          Return Format: "Score: X/9 (Reasoning...)"`;

        try {
          const result = await callGemini(prompt);
          updateFormField('newcastle_ottawa_score', result);
          showToast(" Quality assessed!");
        } catch (e) {
          showToast("Assessment failed", "error");
        } finally {
          setIsLoading(false);
        }
      };

      // --- FEATURE 5: CITATION GENERATOR ---
      const handleGenerateCitation = async () => {
        if (!extractedData.title && !pageOneText) return showToast("No title or text available", "error");
        setIsLoading(true);

        const context = extractedData.title ? `Title: ${extractedData.title}, Authors: ${extractedData.authors}, Year: ${extractedData.year}` : `Abstract: ${pageOneText}`;

        const prompt = `Generate a citation in APA 7th format for this study based on the following info: ${context}. Return ONLY the citation string.`;

        try {
          const result = await callGemini(prompt);
          // Just appending it to the chat for now as a useful place to show it
          setChatMessages(prev => [...prev, { role: 'assistant', text: ` Generated Citation:\n${result}` }]);
          setActiveTab('chat');
          showToast("Citation generated in Chat!");
        } catch (e) {
          showToast("Citation generation failed", "error");
        } finally {
          setIsLoading(false);
        }
      };

      // --- FEATURE 6: HUMAN-IN-THE-LOOP REVIEW ---
      const handleRunAIExtraction = async () => {
        if (!pageOneText) {
          showToast("Upload a PDF first", "error");
          return;
        }
        setIsExtracting(true);
        showToast("Running AI extraction via Genkit...");

        try {
          // Call Genkit Reflection API at localhost:3103 (or configured port)
          const GENKIT_API = 'http://localhost:3103';
          const response = await fetch(`${GENKIT_API}/api/runAction`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              key: '/flow/extractStudyData',
              input: { pdfText: pageOneText }
            })
          });

          if (!response.ok) {
            throw new Error(`Genkit API error: ${response.status}`);
          }

          const result = await response.json();
          if (result.result) {
            setAiExtractedData(result.result);
            setVerifiedFields({});
            setActiveTab('review');
            showToast("AI extraction complete! Review the results.", "success");
          } else if (result.error) {
            throw new Error(result.error.message || 'Extraction failed');
          }
        } catch (e) {
          console.error('AI extraction error:', e);
          showToast(`Extraction failed: ${e.message}`, "error");
        } finally {
          setIsExtracting(false);
        }
      };

      const handleVerifyField = (fieldPath) => {
        setVerifiedFields(prev => ({ ...prev, [fieldPath]: 'verified' }));
        showToast(` Verified: ${fieldPath.split('.').pop()}`);
      };

      const handleFlagField = (fieldPath) => {
        setVerifiedFields(prev => ({ ...prev, [fieldPath]: 'flagged' }));
        showToast(` Flagged: ${fieldPath.split('.').pop()}`, "error");
      };

      const addHighlight = (rect, rawText) => {
        const text = cleanExtractedText(rawText);
        const highlight = {
          id: Date.now(),
          page: pageNum,
          field: currentField,
          rect: rect,
          text: text
        };
        setHighlights([...highlights, highlight]);

        const dataPath = FIELD_MAP[currentField];
        if (dataPath) {
          const keys = dataPath.split('.');
          let currentVal = extractedData;
          keys.forEach(k => currentVal = currentVal[k]);
          const newValue = currentVal ? `${currentVal}; ${text}` : text;
          updateFormField(dataPath, newValue);
          showToast(`Captured: ${currentField}`);
        }
        setSelectionMode(false);
      };

      const handleExport = () => {
        const blob = new Blob([JSON.stringify(extractedData, null, 2)], { type: 'application/json' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = `${extractedData.study_id || 'data'}.json`;
        a.click();
        analytics.logEvent('data_exported', { study_id: extractedData.study_id });
      };

      // Authentication removed - direct access to app
      return (
        <div className="app">
          {isLoading && <div className="loading-overlay"><div className="spinner"></div></div>}


          <PDFPanel
            pdfFile={pdfFile}
            pdfDoc={pdfDoc}
            pageNum={pageNum}
            numPages={numPages}
            highlights={highlights}
            currentField={currentField}
            selectionMode={selectionMode}
            onFileUpload={handleFileUpload}
            onPageChange={setPageNum}
            onFieldSelect={setCurrentField}
            onSelectionModeToggle={setSelectionMode}
            onAddHighlight={addHighlight}
            citationHighlights={citationHighlights}
            activeCitation={activeCitation}
            onCitationClick={(cit) => {
              setActiveCitation(cit);
              if (cit.page !== pageNum) setPageNum(cit.page);
            }}
            citationMarkers={citationMarkers}
            setCitationMarkers={setCitationMarkers}
            availablePdfs={availablePdfs}
            onLoadFromServer={loadPdfFromServer}
          />

          <div className="extraction-panel">
            <div className="extraction-header">
              <div className="header-title-row">
                <h2> Extraction Assistant</h2>
                {saving ? (
                  <span className="save-status saving"><Icons.Cloud size={12} /> Saving...</span>
                ) : (
                  <span className="save-status saved"><Icons.Check size={12} /> Saved</span>
                )}
              </div>
              <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: 10, gap: 8 }}>
                {activeTab === 'extract' && (
                  <>
                    <button
                      className="btn-ai-magic"
                      onClick={handleClaudeCitationExtract}
                      disabled={!pdfDoc}
                      style={{ background: 'linear-gradient(135deg, #6366f1, #8b5cf6)' }}
                      title="Extract with verified source citations"
                    >
                      <Icons.Quote size={12} /> Citations
                    </button>
                    <button className="btn-ai-magic" onClick={handleAiAutofill} disabled={!pageOneText}>
                      <Icons.Wand2 size={12} /> Auto-Fill
                    </button>
                  </>
                )}
              </div>
              <div className="panel-tabs">
                <button className={`tab-btn ${activeTab === 'extract' ? 'active' : ''}`} onClick={() => setActiveTab('extract')}>
                  <Icons.FileText size={14} style={{ marginRight: 4, display: 'inline', verticalAlign: 'middle' }} /> Form
                </button>
                <button className={`tab-btn ${activeTab === 'tables' ? 'active' : ''}`} onClick={() => setActiveTab('tables')}>
                  <Icons.Table size={14} style={{ marginRight: 4, display: 'inline', verticalAlign: 'middle' }} /> Tables
                </button>
                <button className={`tab-btn ${activeTab === 'figures' ? 'active' : ''}`} onClick={() => setActiveTab('figures')}>
                  <Icons.Image size={14} style={{ marginRight: 4, display: 'inline', verticalAlign: 'middle' }} /> Figures
                </button>
                <button className={`tab-btn ${activeTab === 'chat' ? 'active' : ''}`} onClick={() => setActiveTab('chat')}>
                  <Icons.MessageSquare size={14} style={{ marginRight: 4, display: 'inline', verticalAlign: 'middle' }} /> Chat with Paper
                </button>
                <button className={`tab-btn ${activeTab === 'review' ? 'active' : ''}`} onClick={() => setActiveTab('review')}>
                  <Icons.CheckCircle size={14} style={{ marginRight: 4, display: 'inline', verticalAlign: 'middle' }} /> Review
                </button>
              </div>
            </div>

            <div className="extraction-content">
              {activeTab === 'extract' ? (
                <ExtractionForm
                  data={extractedData}
                  highlights={highlights}
                  currentField={currentField}
                  aiFilledFields={aiFilledFields}
                  onUpdate={updateField}
                  onFieldSelect={setCurrentField}
                  onExport={handleExport}
                  onGoToHighlight={setPageNum}
                  onSmartSuggest={handleSmartSuggest}
                  onQualityCheck={handleQualityCheck}
                  onGenerateCitation={handleGenerateCitation}
                  citations={citations}
                  activeCitation={activeCitation}
                  onCitationSelect={(cit) => {
                    setActiveCitation(cit);
                    if (cit.page) setPageNum(cit.page);
                  }}
                  indications={indications}
                  interventions={interventions}
                  studyArms={studyArms}
                  mortalityData={mortalityData}
                  mrsData={mrsData}
                  complications={complications}
                  predictors={predictors}
                  onAddIndication={addIndication}
                  onAddIntervention={addIntervention}
                  onAddArm={addStudyArm}
                  onAddMortality={addMortality}
                  onAddMRS={addMRS}
                  onAddComplication={addComplication}
                  onAddPredictor={addPredictor}
                  onUpdateField={updateField}
                  onRemoveField={removeField}
                />
              ) : activeTab === 'tables' ? (
                <TablesPanel
                  pdfDoc={pdfDoc}
                  pdfFile={pdfFile}
                />
              ) : activeTab === 'figures' ? (
                <FiguresPanel
                  pdfDoc={pdfDoc}
                  pdfFile={pdfFile}
                />
              ) : activeTab === 'review' ? (
                <ReviewPanel
                  extractedData={aiExtractedData}
                  verifiedFields={verifiedFields}
                  onVerify={handleVerifyField}
                  onFlag={handleFlagField}
                  onGoToPage={setPageNum}
                  onRunExtraction={handleRunAIExtraction}
                  isExtracting={isExtracting}
                />
              ) : (
                <ChatInterface
                  messages={chatMessages}
                  onSendMessage={handleSendMessage}
                  hasContext={!!pageOneText}
                />
              )}
            </div>
          </div>

          {toast && <div className={`toast ${toast.type}`}>{toast.message}</div>}
        </div>
      );
    }

    // --- SUB-COMPONENTS ---

    // --- VERIFIABLE FIELD COMPONENT ---
    function VerifiableField({ label, value, sourceText, pageNumber, status, onVerify, onFlag, onGoToPage }) {
      const statusClass = status === 'verified' ? 'verified' : status === 'flagged' ? 'flagged' : '';

      return (
        <div className={`verifiable-field ${statusClass}`}>
          <div className="verifiable-field-header">
            <span className="verifiable-field-label">{label}</span>
            {status && (
              <span style={{ fontSize: 11, color: status === 'verified' ? '#27ae60' : '#e67e22' }}>
                {status === 'verified' ? ' Verified' : ' Flagged'}
              </span>
            )}
          </div>

          <div className="verifiable-field-value">
            {value !== null && value !== undefined ? String(value) : <span style={{ color: '#bdc3c7', fontStyle: 'italic' }}>Not found</span>}
          </div>

          {sourceText && (
            <div className="verifiable-field-source">
              {sourceText}
            </div>
          )}

          <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
            {pageNumber && (
              <button className="verifiable-field-page" onClick={() => onGoToPage(pageNumber)}>
                <Icons.FileText size={12} /> Page {pageNumber}
              </button>
            )}

            <div className="verifiable-field-actions">
              <button className="verify-btn approve" onClick={onVerify} disabled={status === 'verified'}>
                <Icons.Check size={12} /> Verify
              </button>
              <button className="verify-btn flag" onClick={onFlag} disabled={status === 'flagged'}>
                <Icons.AlertTriangle size={12} /> Flag
              </button>
            </div>
          </div>
        </div>
      );
    }

    // --- REVIEW PANEL COMPONENT ---
    function ReviewPanel({ extractedData, verifiedFields, onVerify, onFlag, onGoToPage, onRunExtraction, isExtracting }) {
      if (!extractedData) {
        return (
          <div className="review-panel" style={{ textAlign: 'center', paddingTop: 60 }}>
            <Icons.FileSearch size={48} style={{ color: '#bdc3c7', marginBottom: 16 }} />
            <h3 style={{ color: '#7f8c8d', marginBottom: 12 }}>No AI Extraction Yet</h3>
            <p style={{ color: '#95a5a6', marginBottom: 20, fontSize: 14 }}>
              Run the AI extraction to see verifiable fields with source citations.
            </p>
            <button
              className="btn-ai-magic"
              onClick={onRunExtraction}
              disabled={isExtracting}
              style={{ margin: '0 auto' }}
            >
              <Icons.Zap size={14} />
              {isExtracting ? 'Extracting...' : 'Run AI Extraction'}
            </button>
          </div>
        );
      }

      // Calculate verification progress
      const allFields = [];
      const addFields = (obj, prefix = '') => {
        Object.entries(obj).forEach(([key, val]) => {
          const path = prefix ? `${prefix}.${key}` : key;
          if (val && typeof val === 'object' && 'value' in val && 'sourceText' in val) {
            allFields.push({ path, ...val });
          } else if (val && typeof val === 'object' && !Array.isArray(val)) {
            addFields(val, path);
          }
        });
      };
      addFields(extractedData);

      const verifiedCount = Object.values(verifiedFields).filter(v => v === 'verified').length;
      const flaggedCount = Object.values(verifiedFields).filter(v => v === 'flagged').length;
      const progress = allFields.length > 0 ? ((verifiedCount + flaggedCount) / allFields.length) * 100 : 0;

      return (
        <div className="review-panel">
          <div className="review-header">
            <div className="review-title">
              {extractedData.metadata?.firstAuthor || 'Unknown'} et al. ({extractedData.metadata?.publicationYear || '?'})
            </div>
            <div className="review-meta">
              {extractedData.metadata?.hospitalCenter || 'Unknown Institution'}  {extractedData.metadata?.studyPeriod || 'N/A'}
            </div>
          </div>

          <div className="review-progress">
            <div className="review-progress-bar">
              <div className="review-progress-fill" style={{ width: `${progress}%` }} />
            </div>
            <div className="review-progress-text">
              {verifiedCount} verified  {flaggedCount} flagged  {allFields.length - verifiedCount - flaggedCount} pending
            </div>
          </div>

          {/* Population Section */}
          <div className="review-section">
            <div className="review-section-title">Population</div>
            <VerifiableField
              label="Sample Size"
              value={extractedData.population?.sampleSize}
              sourceText={null}
              pageNumber={null}
              status={verifiedFields['population.sampleSize']}
              onVerify={() => onVerify('population.sampleSize')}
              onFlag={() => onFlag('population.sampleSize')}
              onGoToPage={onGoToPage}
            />
            <VerifiableField
              label="Mean Age"
              value={extractedData.population?.age?.mean?.value}
              sourceText={extractedData.population?.age?.mean?.sourceText}
              pageNumber={extractedData.population?.age?.mean?.pageNumber}
              status={verifiedFields['population.age.mean']}
              onVerify={() => onVerify('population.age.mean')}
              onFlag={() => onFlag('population.age.mean')}
              onGoToPage={onGoToPage}
            />
            <VerifiableField
              label="GCS (Admission)"
              value={extractedData.population?.gcs?.admissionMean?.value}
              sourceText={extractedData.population?.gcs?.admissionMean?.sourceText}
              pageNumber={extractedData.population?.gcs?.admissionMean?.pageNumber}
              status={verifiedFields['population.gcs.admissionMean']}
              onVerify={() => onVerify('population.gcs.admissionMean')}
              onFlag={() => onFlag('population.gcs.admissionMean')}
              onGoToPage={onGoToPage}
            />
            <VerifiableField
              label="Hydrocephalus %"
              value={extractedData.population?.hydrocephalus?.value}
              sourceText={extractedData.population?.hydrocephalus?.sourceText}
              pageNumber={extractedData.population?.hydrocephalus?.pageNumber}
              status={verifiedFields['population.hydrocephalus']}
              onVerify={() => onVerify('population.hydrocephalus')}
              onFlag={() => onFlag('population.hydrocephalus')}
              onGoToPage={onGoToPage}
            />
          </div>

          {/* Intervention Section */}
          <div className="review-section">
            <div className="review-section-title">Intervention</div>
            <VerifiableField
              label="Surgical Technique"
              value={extractedData.intervention?.technique?.value}
              sourceText={extractedData.intervention?.technique?.sourceText}
              pageNumber={extractedData.intervention?.technique?.pageNumber}
              status={verifiedFields['intervention.technique']}
              onVerify={() => onVerify('intervention.technique')}
              onFlag={() => onFlag('intervention.technique')}
              onGoToPage={onGoToPage}
            />
            <VerifiableField
              label="EVD Used"
              value={extractedData.intervention?.evdUsed?.value}
              sourceText={extractedData.intervention?.evdUsed?.sourceText}
              pageNumber={extractedData.intervention?.evdUsed?.pageNumber}
              status={verifiedFields['intervention.evdUsed']}
              onVerify={() => onVerify('intervention.evdUsed')}
              onFlag={() => onFlag('intervention.evdUsed')}
              onGoToPage={onGoToPage}
            />
            <VerifiableField
              label="Duraplasty"
              value={extractedData.intervention?.duraplasty?.value}
              sourceText={extractedData.intervention?.duraplasty?.sourceText}
              pageNumber={extractedData.intervention?.duraplasty?.pageNumber}
              status={verifiedFields['intervention.duraplasty']}
              onVerify={() => onVerify('intervention.duraplasty')}
              onFlag={() => onFlag('intervention.duraplasty')}
              onGoToPage={onGoToPage}
            />
          </div>

          {/* Outcomes Section */}
          <div className="review-section">
            <div className="review-section-title">Outcomes</div>
            <VerifiableField
              label="Mortality"
              value={extractedData.outcomes?.mortality?.value}
              sourceText={extractedData.outcomes?.mortality?.sourceText}
              pageNumber={extractedData.outcomes?.mortality?.pageNumber}
              status={verifiedFields['outcomes.mortality']}
              onVerify={() => onVerify('outcomes.mortality')}
              onFlag={() => onFlag('outcomes.mortality')}
              onGoToPage={onGoToPage}
            />
            <VerifiableField
              label="Favorable mRS"
              value={extractedData.outcomes?.mRS_favorable?.value}
              sourceText={extractedData.outcomes?.mRS_favorable?.sourceText}
              pageNumber={extractedData.outcomes?.mRS_favorable?.pageNumber}
              status={verifiedFields['outcomes.mRS_favorable']}
              onVerify={() => onVerify('outcomes.mRS_favorable')}
              onFlag={() => onFlag('outcomes.mRS_favorable')}
              onGoToPage={onGoToPage}
            />
            <VerifiableField
              label="Length of Stay"
              value={extractedData.outcomes?.lengthOfStay?.value}
              sourceText={extractedData.outcomes?.lengthOfStay?.sourceText}
              pageNumber={extractedData.outcomes?.lengthOfStay?.pageNumber}
              status={verifiedFields['outcomes.lengthOfStay']}
              onVerify={() => onVerify('outcomes.lengthOfStay')}
              onFlag={() => onFlag('outcomes.lengthOfStay')}
              onGoToPage={onGoToPage}
            />
          </div>

          {/* Quality Section */}
          <div className="review-section">
            <div className="review-section-title">Quality Assessment (NOS)</div>
            <div style={{ display: 'grid', gridTemplateColumns: 'repeat(4, 1fr)', gap: 12, marginBottom: 12 }}>
              <div style={{ textAlign: 'center', padding: 12, background: '#f8f9fa', borderRadius: 8 }}>
                <div style={{ fontSize: 24, fontWeight: 700, color: '#3498db' }}>{extractedData.quality?.selectionScore || 0}</div>
                <div style={{ fontSize: 11, color: '#7f8c8d' }}>Selection /4</div>
              </div>
              <div style={{ textAlign: 'center', padding: 12, background: '#f8f9fa', borderRadius: 8 }}>
                <div style={{ fontSize: 24, fontWeight: 700, color: '#9b59b6' }}>{extractedData.quality?.comparabilityScore || 0}</div>
                <div style={{ fontSize: 11, color: '#7f8c8d' }}>Comparability /2</div>
              </div>
              <div style={{ textAlign: 'center', padding: 12, background: '#f8f9fa', borderRadius: 8 }}>
                <div style={{ fontSize: 24, fontWeight: 700, color: '#27ae60' }}>{extractedData.quality?.outcomeScore || 0}</div>
                <div style={{ fontSize: 11, color: '#7f8c8d' }}>Outcome /3</div>
              </div>
              <div style={{ textAlign: 'center', padding: 12, background: 'linear-gradient(135deg, #667eea, #764ba2)', borderRadius: 8, color: 'white' }}>
                <div style={{ fontSize: 24, fontWeight: 700 }}>{extractedData.quality?.totalScore || 0}</div>
                <div style={{ fontSize: 11, opacity: 0.8 }}>Total /9</div>
              </div>
            </div>
            {extractedData.quality?.biasNotes && (
              <div style={{ padding: 12, background: '#fff3cd', borderRadius: 8, fontSize: 13, color: '#856404' }}>
                <strong>Bias Notes:</strong> {extractedData.quality.biasNotes}
              </div>
            )}
          </div>

          {/* Actions */}
          <div style={{ display: 'flex', gap: 12, marginTop: 20 }}>
            <button
              className="btn-ai-magic"
              onClick={onRunExtraction}
              disabled={isExtracting}
            >
              <Icons.RefreshCw size={14} />
              Re-extract
            </button>
          </div>
        </div>
      );
    }

    function ChatInterface({ messages, onSendMessage, hasContext }) {
      const [input, setInput] = useState('');
      const msgEndRef = useRef(null);

      const send = (e) => {
        e.preventDefault();
        if (input.trim()) {
          onSendMessage(input);
          setInput('');
        }
      };

      const handleQuickPrompt = (text) => {
        onSendMessage(text);
      };

      useEffect(() => {
        msgEndRef.current?.scrollIntoView({ behavior: 'smooth' });
      }, [messages]);

      return (
        <div className="chat-container">
          <div className="chat-messages">
            {messages.map((m, i) => (
              <div key={i} className={`message ${m.role}`}>
                {m.role === 'assistant' && <div style={{ fontWeight: 'bold', marginBottom: 4, fontSize: 11, color: '#8e44ad' }}>GEMINI</div>}
                {m.text}
              </div>
            ))}
            <div ref={msgEndRef} />
          </div>

          {hasContext && (
            <div className="quick-prompts">
              {QUICK_PROMPTS.map(p => (
                <button key={p} className="prompt-pill" onClick={() => handleQuickPrompt(p)}>
                  {p}
                </button>
              ))}
            </div>
          )}

          <form className="chat-input-area" onSubmit={send}>
            <input
              className="chat-input"
              placeholder={hasContext ? "Ask about the paper..." : "Upload a PDF first..."}
              value={input}
              onChange={e => setInput(e.target.value)}
              disabled={!hasContext}
            />
            <button type="submit" className="btn-send" disabled={!hasContext}>
              <Icons.Send size={16} />
            </button>
          </form>
        </div>
      );
    }

    function ExtractionForm({
      data, highlights, currentField, aiFilledFields, onUpdate, onFieldSelect, onExport, onGoToHighlight,
      onSmartSuggest, onQualityCheck, onGenerateCitation, citations, activeCitation, onCitationSelect,
      indications = [], interventions = [], studyArms = [], mortalityData = [], mrsData = [], complications = [], predictors = [],
      onAddIndication, onAddIntervention, onAddArm, onAddMortality, onAddMRS, onAddComplication, onAddPredictor,
      onUpdateField, onRemoveField
    }) {
      const currentPath = FIELD_MAP[currentField];
      const [collapsed, setCollapsed] = useState({ pop: false, int: false, out: false, meta: false, cit: false });
      const toggle = (sec) => setCollapsed(prev => ({ ...prev, [sec]: !prev[sec] }));

      const Input = ({ label, path, type = "text", rows }) => {
        const val = path.split('.').reduce((o, i) => o[i], data);
        const isAi = aiFilledFields.has(path);
        const isFocused = currentPath === path;
        const [isSuggesting, setIsSuggesting] = useState(false);

        const triggerSuggest = async () => {
          setIsSuggesting(true);
          await onSmartSuggest(label, path);
          setIsSuggesting(false);
        };

        // Locate button - search for this value in the PDF
        const handleLocate = () => {
          if (val && window.jumpToCitation) {
            window.jumpToCitation(val, label);
          }
        };

        return (
          <div className="form-group">
            <label>{label}</label>
            <div className="input-wrapper">
              {rows ? (
                <textarea className={`form-control ${isAi ? 'ai-filled' : ''} ${isFocused ? 'field-focused' : ''}`}
                  value={val} onChange={e => onUpdate(path, e.target.value)}
                  onFocus={() => onFieldSelect(Object.keys(FIELD_MAP).find(key => FIELD_MAP[key] === path))} rows={rows} />
              ) : (
                <input className={`form-control ${isAi ? 'ai-filled' : ''} ${isFocused ? 'field-focused' : ''}`}
                  type={type} value={val} onChange={e => onUpdate(path, e.target.value)}
                  onFocus={() => onFieldSelect(Object.keys(FIELD_MAP).find(key => FIELD_MAP[key] === path))} />
              )}
              <div className="input-actions">
                {val && (
                  <button className="btn-citation"
                    onClick={handleLocate} title={`Locate "${label}" in PDF`} type="button">
                    <Icons.MapPin size={14} />
                  </button>
                )}
                <button className={`btn-suggest ${isSuggesting ? 'loading' : ''}`}
                  onClick={triggerSuggest} title="Ask Gemini to find this" type="button">
                  <Icons.Wand2 size={14} />
                </button>
              </div>
            </div>
          </div>
        );
      };

      return (
        <div className="extraction-form-container">
          <div className="form-section">
            <div className="section-header" onClick={() => toggle('meta')}>
              <div className="section-title"> Study Identification</div>
              <Icons.ChevronDown size={16} style={{ transform: collapsed.meta ? 'rotate(-90deg)' : '' }} />
            </div>
            <div className={`section-body ${collapsed.meta ? 'collapsed' : ''}`}>
              <div style={{ display: 'flex', alignItems: 'center', marginBottom: 10 }}>
                <button className="btn-quality-check" onClick={onGenerateCitation} style={{ marginLeft: 0 }}>
                  <Icons.Quote size={12} /> Generate Citation
                </button>
              </div>
              <Input label="Study ID" path="study_id" />
              <Input label="Authors" path="authors" />
              <div style={{ display: 'flex', gap: '10px' }}>
                <div style={{ flex: 1 }}><Input label="Year" path="year" /></div>
                <div style={{ flex: 2 }}><Input label="Design" path="study_design" /></div>
              </div>
              <Input label="Title" path="title" />
            </div>
          </div>

          <div className="form-section">
            <div className="section-header" onClick={() => toggle('pop')}>
              <div className="section-title"> Population</div>
            </div>
            <div className={`section-body ${collapsed.pop ? 'collapsed' : ''}`}>
              <div style={{ display: 'flex', gap: '10px' }}>
                <div style={{ flex: 1 }}><Input label="Sample Size" path="population.sample_size" /></div>
                <div style={{ flex: 1 }}><Input label="Mean Age" path="population.mean_age" /></div>
              </div>
              <Input label="Inclusion Criteria" path="population.inclusion_criteria" rows={3} />
            </div>
          </div>

          <div className="form-section">
            <div className="section-header" onClick={() => toggle('int')}>
              <div className="section-title"> Intervention</div>
            </div>
            <div className={`section-body ${collapsed.int ? 'collapsed' : ''}`}>
              <Input label="Procedure" path="intervention.procedure" />
              <Input label="Timing (Hours)" path="intervention.timing_hours" />
              <Input label="Technique" path="intervention.technique" rows={2} />
              <Input label="Comparator" path="comparator" />
            </div>
          </div>

          <div className="form-section">
            <div className="section-header" onClick={() => toggle('out')}>
              <div className="section-title"> Outcomes</div>
            </div>
            <div className={`section-body ${collapsed.out ? 'collapsed' : ''}`}>
              <div style={{ display: 'flex', gap: '10px' }}>
                <div style={{ flex: 1 }}><Input label="Mortality" path="outcomes.mortality" /></div>
                <div style={{ flex: 1 }}><Input label="Favorable Outcome" path="outcomes.mRS_favorable" /></div>
              </div>
              <Input label="Complications" path="outcomes.complications" rows={3} />
              <Input label="Length of Stay" path="outcomes.length_of_stay" />

              <div style={{ marginTop: 15, paddingTop: 15, borderTop: '1px dashed #eee' }}>
                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: 5 }}>
                  <label style={{ fontSize: 12, fontWeight: 600, color: '#7f8c8d', textTransform: 'uppercase' }}>Quality Score</label>
                  <button className="btn-quality-check" onClick={onQualityCheck}>
                    <Icons.Activity size={12} /> Analyze Quality
                  </button>
                </div>
                <Input label="" path="newcastle_ottawa_score" />
              </div>
            </div>
          </div>

          {/* Citation Provenance Panel */}
          {citations && citations.length > 0 && (
            <div className="citation-panel">
              <div className="citation-panel-header" onClick={() => toggle('cit')}>
                <span> Verified Citations ({citations.length})</span>
                <Icons.ChevronDown size={16} style={{ marginLeft: 'auto', transform: collapsed.cit ? 'rotate(-90deg)' : '' }} />
              </div>
              {!collapsed.cit && citations.map((cit, idx) => (
                <div
                  key={cit.id || idx}
                  className={`citation-card ${activeCitation?.id === cit.id ? 'active' : ''}`}
                  onClick={() => onCitationSelect(cit)}
                >
                  <div className="citation-field">{cit.field || 'Extracted Value'}</div>
                  <div className="citation-value">{cit.value || cit.citedText?.substring(0, 60)}</div>
                  <div className="citation-source">
                    "{cit.sourceText || cit.citedText}"
                  </div>
                  <div className="citation-meta">
                    <span>Page {cit.page}</span>
                    <span>Chars {cit.startChar}-{cit.endChar}</span>
                    <button
                      className="btn-citation has-citation"
                      onClick={(e) => {
                        e.stopPropagation();
                        const sourceText = cit.sourceText || cit.citedText;
                        const fieldName = cit.field || cit.value?.substring(0, 30) || 'Citation';
                        if (sourceText && window.jumpToCitation) {
                          window.jumpToCitation(sourceText, fieldName);
                        }
                      }}
                      title="Jump to citation and highlight"
                      style={{ marginLeft: 'auto', padding: '2px 8px' }}
                    >
                       Locate
                    </button>
                  </div>
                </div>
              ))}
            </div>
          )}

          {highlights.length > 0 && (
            <div className="annotations-container">
              <h3 style={{ fontSize: '12px', fontWeight: 600, color: '#777', marginBottom: '10px', marginTop: '20px' }}>CAPTURED SNIPPETS</h3>
              {highlights.map(h => (
                <div key={h.id} className="annotation-card">
                  <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start' }}>
                    <div onClick={() => onGoToHighlight(h.page)} style={{ cursor: 'pointer', flex: 1 }}>
                      <strong>{h.field} (Pg {h.page})</strong>
                      <p style={{ margin: '4px 0 0' }}>{h.text}</p>
                    </div>
                    {h.text && !h.temporary && (
                      <button
                        className="btn-citation has-citation"
                        onClick={(e) => {
                          e.stopPropagation();
                          if (window.jumpToCitation) {
                            window.jumpToCitation(h.text, h.field || 'Snippet');
                          }
                        }}
                        title="Jump and highlight"
                        style={{ padding: '2px 6px', marginLeft: '8px' }}
                      >
                        
                      </button>
                    )}
                  </div>
                </div>
              ))}
            </div>
          )}

          {/* ========== 7 DYNAMIC FIELD SECTIONS (from DetailedExtractionPanel) ========== */}

          {/* Study Arms Section (CRITICAL: Must come first for linked selectors) */}
          <div className="field-section">
            <h3> Study Arms</h3>
            <p className="field-section-description">
              Define treatment groups. These arms will automatically appear in mortality, mRS, and complication selectors.
            </p>
            <button className="add-field-btn" onClick={onAddArm}>
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <path d="M12 5v14m-7-7h14" />
              </svg>
              Add Study Arm
            </button>
            {studyArms.length === 0 ? (
              <div className="empty-state">Add your first study arm to enable arm-specific data collection</div>
            ) : (
              studyArms.map((arm, i) => (
                <StudyArmField
                  key={arm.id}
                  data={arm}
                  index={i}
                  onUpdate={(field, value) => onUpdateField('arm', arm.id, field, value)}
                  onRemove={() => onRemoveField('arm', arm.id)}
                />
              ))
            )}
          </div>

          {/* Indications Section */}
          <div className="field-section">
            <h3> Indications for Surgery</h3>
            <p className="field-section-description">Signs and symptoms that indicated need for surgical intervention.</p>
            <button className="add-field-btn" onClick={onAddIndication}>
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <path d="M12 5v14m-7-7h14" />
              </svg>
              Add Indication
            </button>
            {indications.length === 0 ? (
              <div className="empty-state">No indications added yet</div>
            ) : (
              indications.map((indication, i) => (
                <IndicationField
                  key={indication.id}
                  data={indication}
                  index={i}
                  onUpdate={(field, value) => onUpdateField('indication', indication.id, field, value)}
                  onRemove={() => onRemoveField('indication', indication.id)}
                />
              ))
            )}
          </div>

          {/* Interventions Section */}
          <div className="field-section">
            <h3> Interventions</h3>
            <p className="field-section-description">Surgical procedures and intervention details.</p>
            <button className="add-field-btn" onClick={onAddIntervention}>
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <path d="M12 5v14m-7-7h14" />
              </svg>
              Add Intervention
            </button>
            {interventions.length === 0 ? (
              <div className="empty-state">No interventions added yet</div>
            ) : (
              interventions.map((intervention, i) => (
                <InterventionField
                  key={intervention.id}
                  data={intervention}
                  index={i}
                  onUpdate={(field, value) => onUpdateField('intervention', intervention.id, field, value)}
                  onRemove={() => onRemoveField('intervention', intervention.id)}
                />
              ))
            )}
          </div>

          {/* Mortality Section */}
          <div className="field-section">
            <h3> Mortality Data</h3>
            <p className="field-section-description">Mortality outcomes by study arm and timepoint.</p>
            <button className="add-field-btn" onClick={onAddMortality}>
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <path d="M12 5v14m-7-7h14" />
              </svg>
              Add Mortality Data Point
            </button>
            {mortalityData.length === 0 ? (
              <div className="empty-state">No mortality data added yet. Add study arms first to enable arm selection.</div>
            ) : (
              mortalityData.map((mortality, i) => (
                <MortalityField
                  key={mortality.id}
                  data={mortality}
                  index={i}
                  availableArms={studyArms.filter(arm => arm.label.trim())}
                  onUpdate={(field, value) => onUpdateField('mortality', mortality.id, field, value)}
                  onRemove={() => onRemoveField('mortality', mortality.id)}
                />
              ))
            )}
          </div>

          {/* mRS Section */}
          <div className="field-section">
            <h3> mRS Distribution</h3>
            <p className="field-section-description">Modified Rankin Scale outcomes with full 0-6 score distribution.</p>
            <button className="add-field-btn" onClick={onAddMRS}>
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <path d="M12 5v14m-7-7h14" />
              </svg>
              Add mRS Data Point
            </button>
            {mrsData.length === 0 ? (
              <div className="empty-state">No mRS data added yet. Add study arms first to enable arm selection.</div>
            ) : (
              mrsData.map((mrs, i) => (
                <MRSField
                  key={mrs.id}
                  data={mrs}
                  index={i}
                  availableArms={studyArms.filter(arm => arm.label.trim())}
                  onUpdate={(field, value) => onUpdateField('mrs', mrs.id, field, value)}
                  onRemove={() => onRemoveField('mrs', mrs.id)}
                />
              ))
            )}
          </div>

          {/* Complications Section */}
          <div className="field-section">
            <h3> Complications</h3>
            <p className="field-section-description">Adverse events and complications by study arm.</p>
            <button className="add-field-btn" onClick={onAddComplication}>
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <path d="M12 5v14m-7-7h14" />
              </svg>
              Add Complication
            </button>
            {complications.length === 0 ? (
              <div className="empty-state">No complications added yet. Add study arms first to enable arm selection.</div>
            ) : (
              complications.map((complication, i) => (
                <ComplicationField
                  key={complication.id}
                  data={complication}
                  index={i}
                  availableArms={studyArms.filter(arm => arm.label.trim())}
                  onUpdate={(field, value) => onUpdateField('complication', complication.id, field, value)}
                  onRemove={() => onRemoveField('complication', complication.id)}
                />
              ))
            )}
          </div>

          {/* Predictors Section */}
          <div className="field-section">
            <h3> Predictor Analyses</h3>
            <p className="field-section-description">Statistical predictors with effect sizes and confidence intervals.</p>
            <button className="add-field-btn" onClick={onAddPredictor}>
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <path d="M12 5v14m-7-7h14" />
              </svg>
              Add Predictor
            </button>
            {predictors.length === 0 ? (
              <div className="empty-state">No predictors added yet</div>
            ) : (
              predictors.map((predictor, i) => (
                <PredictorField
                  key={predictor.id}
                  data={predictor}
                  index={i}
                  onUpdate={(field, value) => onUpdateField('predictor', predictor.id, field, value)}
                  onRemove={() => onRemoveField('predictor', predictor.id)}
                />
              ))
            )}
          </div>

          {/* ========== END OF 7 DYNAMIC FIELD SECTIONS ========== */}

          <div className="panel-footer" style={{ marginTop: 20, padding: 0, borderTop: 'none' }}>
            <button className="action-btn btn-export-json" onClick={onExport}>Download JSON</button>
          </div>
        </div>
      );
    }

    function PDFPanel({
      pdfFile, pdfDoc, pageNum, numPages, highlights,
      currentField, selectionMode, onFileUpload, onPageChange,
      onFieldSelect, onSelectionModeToggle, onAddHighlight,
      citationHighlights, activeCitation, onCitationClick, onViewportChange,
      citationMarkers, setCitationMarkers,
      availablePdfs = [], onLoadFromServer
    }) {
      const canvasRef = useRef(null);
      const [scale, setScale] = useState(1.2);
      const [textContent, setTextContent] = useState(null);
      const [viewport, setViewport] = useState(null);

      useEffect(() => {
        if (pdfDoc) renderPage();
      }, [pdfDoc, pageNum, scale]);

      useEffect(() => {
        const canvas = canvasRef.current;
        if (!selectionMode || !canvas || !textContent) return;

        let startX, startY, isDrawing = false;
        let selectionBox = document.createElement('div');
        selectionBox.style.cssText = 'position:absolute; border: 2px dashed #f39c12; background: rgba(243, 156, 18, 0.2); pointer-events: none; z-index: 50;';

        const getCoords = (e) => {
          const rect = canvas.getBoundingClientRect();
          return { x: e.clientX - rect.left, y: e.clientY - rect.top };
        };

        const onDown = (e) => {
          const { x, y } = getCoords(e);
          startX = x; startY = y;
          isDrawing = true;
          selectionBox.style.left = x + 'px'; selectionBox.style.top = y + 'px';
          canvas.parentElement.appendChild(selectionBox);
        };

        const onMove = (e) => {
          if (!isDrawing) return;
          const { x, y } = getCoords(e);
          const left = Math.min(startX, x), top = Math.min(startY, y);
          const width = Math.abs(x - startX), height = Math.abs(y - startY);
          selectionBox.style.left = left + 'px'; selectionBox.style.top = top + 'px';
          selectionBox.style.width = width + 'px'; selectionBox.style.height = height + 'px';
        };

        const onUp = (e) => {
          if (!isDrawing) return;
          isDrawing = false;
          const { x, y } = getCoords(e);
          selectionBox.remove();
          const rect = {
            left: Math.min(startX, x), top: Math.min(startY, y),
            width: Math.abs(x - startX), height: Math.abs(y - startY)
          };
          if (rect.width < 5 || rect.height < 5) return;
          onAddHighlight(rect, "Selected Text (Simulated Extraction)");
        };

        canvas.addEventListener('mousedown', onDown);
        window.addEventListener('mousemove', onMove);
        window.addEventListener('mouseup', onUp);

        return () => {
          canvas.removeEventListener('mousedown', onDown);
          window.removeEventListener('mousemove', onMove);
          window.removeEventListener('mouseup', onUp);
          if (selectionBox.parentNode) selectionBox.parentNode.removeChild(selectionBox);
        };
      }, [selectionMode, textContent]);

      const renderPage = async () => {
        try {
          const page = await pdfDoc.getPage(pageNum);
          const vp = page.getViewport({ scale });
          setViewport(vp);
          if (onViewportChange) onViewportChange(vp);

          const canvas = canvasRef.current;
          const ctx = canvas.getContext('2d');
          canvas.width = vp.width;
          canvas.height = vp.height;
          await page.render({ canvasContext: ctx, viewport: vp }).promise;
          const text = await page.getTextContent();
          setTextContent(text);
        } catch (e) { console.error(e); }
      };

      return (
        <div className="pdf-panel">
          <div className="pdf-header">
            <h2> PDF Explorer</h2>
            <div style={{ display: 'flex', gap: '10px', alignItems: 'center' }}>
              {availablePdfs.length > 0 && (
                <select
                  onChange={(e) => onLoadFromServer && onLoadFromServer(e.target.value)}
                  defaultValue=""
                  style={{
                    padding: '8px 12px',
                    borderRadius: '4px',
                    border: '1px solid #ccc',
                    background: '#f8f9fa',
                    cursor: 'pointer',
                    fontSize: '14px'
                  }}
                >
                  <option value="" disabled> Select PDF...</option>
                  {availablePdfs.map((pdf, idx) => (
                    <option key={idx} value={pdf.filename}>{pdf.name}</option>
                  ))}
                </select>
              )}
              <label className="file-upload-btn">
                Upload PDF
                <input type="file" accept=".pdf" onChange={e => onFileUpload(e.target.files[0])} />
              </label>
            </div>
          </div>

          {pdfFile && (
            <div className="pdf-controls">
              <button className="control-btn" onClick={() => onPageChange(Math.max(1, pageNum - 1))} disabled={pageNum <= 1}>Previous</button>
              <span style={{ fontSize: '12px', margin: '0 10px' }}>Page {pageNum} / {numPages}</span>
              <button className="control-btn" onClick={() => onPageChange(Math.min(numPages, pageNum + 1))} disabled={pageNum >= numPages}>Next</button>
              <div style={{ width: '1px', height: '16px', background: '#666', margin: '0 10px' }}></div>
              <button className="control-btn" onClick={() => setScale(s => Math.max(0.5, s - 0.2))}>-</button>
              <span style={{ fontSize: '12px' }}>{Math.round(scale * 100)}%</span>
              <button className="control-btn" onClick={() => setScale(s => Math.min(3, s + 0.2))}>+</button>
            </div>
          )}

          <div className="annotation-bar">
            <select className="field-select" value={currentField} onChange={e => onFieldSelect(e.target.value)}>
              <option value="">-- Select Field to Extract --</option>
              {Object.keys(FIELD_MAP).map(k => <option key={k} value={k}>{k}</option>)}
            </select>

            <button
              className={`toggle-highlight-btn ${selectionMode ? 'active' : ''}`}
              onClick={() => onSelectionModeToggle(!selectionMode)}
              disabled={!currentField}
              title={!currentField ? "Select a field first" : "Click and drag on PDF"}
            >
              {selectionMode ? ' Highlighting...' : 'Enable Selection'}
            </button>
          </div>

          <div className="pdf-viewer-container">
            {pdfFile ? (
              <div className="pdf-canvas-wrapper">
                <canvas ref={canvasRef} id="pdf-canvas" style={{ cursor: selectionMode ? 'crosshair' : 'default' }} />
                <div className="highlight-layer">
                  {/* Manual selection highlights (yellow) */}
                  {highlights.filter(h => h.page === pageNum).map(h => (
                    <div key={h.id} className="highlight"
                      style={{ left: h.rect.left, top: h.rect.top, width: h.rect.width, height: h.rect.height }}
                      title={h.field + ": " + h.text} />
                  ))}

                  {/* Claude citation highlights (purple) */}
                  {viewport && citationHighlights && citationHighlights
                    .filter(c => c.page === pageNum)
                    .map((c, idx) => {
                      const rect = pdfToCanvasCoords(c.x, c.y, c.width, c.height, viewport);
                      const isActive = activeCitation && activeCitation.id === c.id;
                      return (
                        <div
                          key={`cit-${idx}-${c.page}`}
                          className={`citation-highlight ${isActive ? 'active' : ''}`}
                          style={{
                            left: rect.left,
                            top: rect.top,
                            width: Math.max(rect.width, 10),
                            height: Math.max(rect.height, 12)
                          }}
                          title={`Citation: "${c.citedText?.substring(0, 50)}..."`}
                          onClick={() => onCitationClick && onCitationClick(c)}
                        />
                      );
                    })}

                  {/* Citation jump markers (yellow  persistent orange border with tooltip) */}
                  {citationMarkers && citationMarkers
                    .filter(m => m.page === pageNum)
                    .map((m) => (
                      <div
                        key={`marker-${m.id}`}
                        className={`citation-jump-highlight ${m.persistent ? 'persistent' : ''}`}
                        style={{
                          left: m.rect.x,
                          top: m.rect.y,
                          width: m.rect.width,
                          height: m.rect.height,
                          background: m.isYellow ? 'rgba(255, 235, 59, 0.6)' : 'rgba(255, 235, 59, 0.15)'
                        }}
                        onClick={() => {
                          // Click to remove this marker
                          setCitationMarkers(prev => prev.filter(h => h.id !== m.id));
                        }}
                      >
                        <span className="citation-tooltip">{m.tooltipText}</span>
                      </div>
                    ))}
                </div>
              </div>
            ) : (
              <div style={{ textAlign: 'center', marginTop: '100px', opacity: 0.5, color: '#333' }}>
                <div style={{ fontSize: '40px', marginBottom: '20px' }}></div>
                <div>Upload a PDF Document to begin</div>
              </div>
            )}
          </div>
        </div>
      );
    }

    ReactDOM.render(<App />, document.getElementById('root'));
  </script>

  <!--  Google Generative AI (Gemini) - Browser-compatible SDK -->
  <script type="module">
    import { GoogleGenerativeAI } from 'https://esm.sh/@google/generative-ai';

    //  Replace with your actual API key (visible in browser - OK for dev, not for production)
    const API_KEY = 'GOOGLE_GENAI_API_KEY';

    // Initialize the Gemini client
    const genAI = new GoogleGenerativeAI(API_KEY);
    const model = genAI.getGenerativeModel({ model: 'gemini-1.5-flash' });

    // Example: Hello flow equivalent
    async function helloFlow(name) {
      try {
        const result = await model.generateContent(`Hello Gemini, my name is ${name}`);
        const response = await result.response;
        const text = response.text();
        console.log('Gemini response:', text);
        return text;
      } catch (error) {
        console.error('Gemini error:', error);
      }
    }

    // Make it globally accessible for testing
    window.helloFlow = helloFlow;
    window.geminiModel = model;

    // Test call (uncomment to run on page load)
    // helloFlow('Chris');

    console.log(' Google Generative AI SDK loaded. Try: helloFlow("YourName") in console');
  </script>
</body>

</html>