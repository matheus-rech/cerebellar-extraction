<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CEREBELLAR-EXTRACT - Data Extraction Tool</title>

  <!-- Firebase SDKs (Compat) -->
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-functions-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-analytics-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-performance-compat.js"></script>

  <!-- PDF.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>

  <!-- React & ReactDOM -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>

  <!-- Babel for JSX -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <style>
    /* Reset and base styles */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --primary: #3498db;
      --primary-dark: #2980b9;
      --secondary: #2c3e50;
      --accent: #f39c12;
      --accent-hover: #e67e22;
      --ai-color: #8e44ad;
      --ai-bg: #f5eef8;
      --success: #27ae60;
      --bg-grey: #eef2f5;
      --border: #dce4ec;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: var(--bg-grey);
      color: #333;
    }

    .app {
      display: flex;
      height: 100vh;
      overflow: hidden;
    }

    /* --- LEFT PANEL: PDF VIEWER --- */
    .pdf-panel {
      flex: 1;
      display: flex;
      flex-direction: column;
      background: #525659;
      /* Neutral dark grey for PDF backdrop */
      color: white;
      overflow: hidden;
      position: relative;
    }

    .pdf-header {
      padding: 12px 20px;
      background: #323639;
      border-bottom: 1px solid #000;
      display: flex;
      justify-content: space-between;
      align-items: center;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      z-index: 10;
    }

    .pdf-header h2 {
      font-size: 16px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    /* File upload styling */
    .file-upload-btn {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 16px;
      background: var(--primary);
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      transition: background 0.2s;
      position: relative;
      overflow: hidden;
    }

    .file-upload-btn:hover {
      background: var(--primary-dark);
    }

    .file-upload-btn input[type="file"] {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      opacity: 0;
      cursor: pointer;
    }

    /* Controls Bar */
    .pdf-controls {
      padding: 8px 16px;
      background: #424649;
      display: flex;
      gap: 8px;
      align-items: center;
      justify-content: center;
      border-bottom: 1px solid #000;
    }

    .control-btn {
      padding: 4px 8px;
      background: transparent;
      color: #f0f0f0;
      border: 1px solid #666;
      border-radius: 3px;
      cursor: pointer;
      font-size: 12px;
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .control-btn:hover:not(:disabled) {
      background: rgba(255, 255, 255, 0.1);
    }

    .control-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* Annotation Bar */
    .annotation-bar {
      padding: 10px 16px;
      background: #fff;
      display: flex;
      gap: 12px;
      align-items: center;
      border-bottom: 1px solid var(--border);
      color: #333;
    }

    .field-select {
      padding: 6px 10px;
      border-radius: 4px;
      border: 1px solid var(--border);
      background: white;
      font-size: 13px;
      min-width: 200px;
    }

    .toggle-highlight-btn {
      padding: 6px 12px;
      background: var(--bg-grey);
      color: #555;
      border: 1px solid var(--border);
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: 6px;
      transition: all 0.2s;
    }

    .toggle-highlight-btn.active {
      background: #fff3cd;
      color: #856404;
      border-color: #ffeeba;
      box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.05);
    }

    .toggle-highlight-btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    /* PDF Canvas Container */
    .pdf-viewer-container {
      flex: 1;
      overflow: auto;
      padding: 40px;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      background-image: radial-gradient(#666 1px, transparent 1px);
      background-size: 20px 20px;
    }

    .pdf-canvas-wrapper {
      position: relative;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.4);
      background: white;
    }

    #pdf-canvas {
      display: block;
    }

    .highlight-layer {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
    }

    .highlight {
      position: absolute;
      background: rgba(255, 235, 59, 0.3);
      border: 1px solid rgba(255, 193, 7, 0.8);
      pointer-events: auto;
      cursor: pointer;
      transition: opacity 0.2s;
    }

    .highlight:hover {
      background: rgba(255, 235, 59, 0.5);
      z-index: 10;
    }

    /* Citation highlights (from Claude Native Citations) */
    .citation-highlight {
      position: absolute;
      background: rgba(138, 43, 226, 0.25);
      border: 1px solid rgba(138, 43, 226, 0.6);
      pointer-events: auto;
      cursor: pointer;
      transition: all 0.2s;
      border-radius: 2px;
    }

    .citation-highlight:hover {
      background: rgba(138, 43, 226, 0.4);
      z-index: 10;
    }

    .citation-highlight.active {
      background: rgba(138, 43, 226, 0.5);
      border-width: 2px;
      box-shadow: 0 0 8px rgba(138, 43, 226, 0.5);
    }

    /* Citation panel styles */
    .citation-panel {
      background: #f8f4ff;
      border: 1px solid #d4c4e8;
      border-radius: 6px;
      margin-bottom: 15px;
      overflow: hidden;
    }

    .citation-panel-header {
      padding: 10px 12px;
      background: linear-gradient(135deg, #8e44ad, #9b59b6);
      color: white;
      font-size: 13px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .citation-card {
      padding: 10px 12px;
      border-bottom: 1px solid #e8dff2;
      cursor: pointer;
      transition: background 0.2s;
    }

    .citation-card:last-child {
      border-bottom: none;
    }

    .citation-card:hover {
      background: #f0e8f8;
    }

    .citation-card.active {
      background: #e8d8f4;
      border-left: 3px solid #8e44ad;
    }

    .citation-field {
      font-size: 11px;
      font-weight: 600;
      color: #8e44ad;
      text-transform: uppercase;
      margin-bottom: 4px;
    }

    .citation-value {
      font-size: 13px;
      color: #2c3e50;
      margin-bottom: 6px;
    }

    .citation-source {
      font-size: 11px;
      color: #666;
      font-style: italic;
      background: white;
      padding: 6px 8px;
      border-radius: 4px;
      border-left: 2px solid #9b59b6;
      max-height: 60px;
      overflow-y: auto;
    }

    .citation-meta {
      font-size: 10px;
      color: #999;
      margin-top: 6px;
      display: flex;
      gap: 12px;
    }

    /* --- RIGHT PANEL: EXTRACTION FORM --- */
    .extraction-panel {
      width: 480px;
      background: white;
      display: flex;
      flex-direction: column;
      border-left: 1px solid var(--border);
      box-shadow: -2px 0 10px rgba(0, 0, 0, 0.05);
      z-index: 20;
    }

    .extraction-header {
      padding: 20px 20px 0 20px;
      /* Reduced bottom padding for tabs */
      background: white;
      border-bottom: 1px solid var(--border);
    }

    .header-title-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 5px;
    }

    .extraction-header h2 {
      font-size: 18px;
      color: var(--secondary);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .save-status {
      font-size: 11px;
      color: #7f8c8d;
      display: flex;
      align-items: center;
      gap: 4px;
      background: #f8f9fa;
      padding: 2px 8px;
      border-radius: 12px;
      border: 1px solid #eee;
    }

    .save-status.saving {
      color: var(--accent);
    }

    .save-status.saved {
      color: var(--success);
    }

    /* TABS */
    .panel-tabs {
      display: flex;
      gap: 20px;
      margin-top: 10px;
    }

    .tab-btn {
      background: none;
      border: none;
      padding: 8px 0;
      font-size: 13px;
      font-weight: 600;
      color: #7f8c8d;
      cursor: pointer;
      position: relative;
    }

    .tab-btn.active {
      color: var(--primary);
    }

    .tab-btn.active::after {
      content: '';
      position: absolute;
      bottom: -1px;
      /* Overlap border */
      left: 0;
      right: 0;
      height: 2px;
      background: var(--primary);
    }

    /* AI Buttons */
    .btn-ai-magic {
      padding: 6px 12px;
      font-size: 12px;
      font-weight: 600;
      background: linear-gradient(135deg, #8e44ad, #9b59b6);
      color: white;
      border: none;
      border-radius: 20px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 6px;
      box-shadow: 0 2px 5px rgba(142, 68, 173, 0.3);
      transition: transform 0.1s, box-shadow 0.1s;
    }

    .btn-ai-magic:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(142, 68, 173, 0.4);
    }

    .btn-ai-magic:active {
      transform: translateY(0);
    }

    .btn-ai-magic:disabled {
      background: #ccc;
      box-shadow: none;
      cursor: not-allowed;
    }

    .btn-quality-check {
      padding: 4px 8px;
      font-size: 11px;
      background: #f8f9fa;
      color: var(--ai-color);
      border: 1px solid var(--ai-color);
      border-radius: 4px;
      cursor: pointer;
      margin-left: auto;
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .btn-quality-check:hover {
      background: var(--ai-bg);
    }

    /* Form Body */
    .extraction-content {
      flex: 1;
      overflow-y: auto;
      background: #fcfcfc;
      position: relative;
    }

    .extraction-form-container {
      padding: 20px;
    }

    /* Chat Interface */
    .chat-container {
      display: flex;
      flex-direction: column;
      height: 100%;
      background: #f8f9fa;
    }

    .chat-messages {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .message {
      max-width: 85%;
      padding: 10px 14px;
      border-radius: 12px;
      font-size: 13px;
      line-height: 1.4;
      position: relative;
    }

    .message.user {
      align-self: flex-end;
      background: var(--primary);
      color: white;
      border-bottom-right-radius: 2px;
    }

    .message.assistant {
      align-self: flex-start;
      background: white;
      border: 1px solid var(--border);
      color: #2c3e50;
      border-bottom-left-radius: 2px;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
    }

    .message.system {
      align-self: center;
      background: transparent;
      color: #7f8c8d;
      font-size: 11px;
      font-style: italic;
      border: none;
      box-shadow: none;
      text-align: center;
    }

    .quick-prompts {
      display: flex;
      gap: 8px;
      padding: 10px 15px;
      overflow-x: auto;
      white-space: nowrap;
      border-top: 1px solid var(--border);
      background: white;
      -ms-overflow-style: none;
      /* IE and Edge */
      scrollbar-width: none;
      /* Firefox */
    }

    .quick-prompts::-webkit-scrollbar {
      display: none;
    }

    .prompt-pill {
      padding: 6px 12px;
      background: #f0f2f5;
      color: #555;
      border: 1px solid #e4e6eb;
      border-radius: 16px;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.2s;
      flex-shrink: 0;
    }

    .prompt-pill:hover {
      background: var(--ai-bg);
      color: var(--ai-color);
      border-color: var(--ai-color);
    }

    .chat-input-area {
      padding: 15px;
      background: white;
      border-top: 1px solid var(--border);
      display: flex;
      gap: 8px;
    }

    .chat-input {
      flex: 1;
      padding: 8px 12px;
      border: 1px solid var(--border);
      border-radius: 20px;
      font-size: 13px;
      outline: none;
    }

    .chat-input:focus {
      border-color: var(--primary);
    }

    .btn-send {
      background: var(--primary);
      color: white;
      border: none;
      width: 36px;
      height: 36px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }

    /* Accordion Sections */
    .form-section {
      margin-bottom: 20px;
      background: white;
      border: 1px solid var(--border);
      border-radius: 6px;
      overflow: hidden;
    }

    .form-section:last-child {
      margin-bottom: 0;
    }

    .section-header {
      padding: 12px 15px;
      background: #f8f9fa;
      border-bottom: 1px solid var(--border);
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer;
      -webkit-user-select: none;
      user-select: none;
      transition: background 0.2s;
    }

    .section-header:hover {
      background: #eef2f5;
    }

    .section-title {
      font-size: 14px;
      font-weight: 600;
      color: var(--secondary);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .section-actions {
      display: flex;
      gap: 8px;
    }

    .btn-clear-section {
      padding: 2px 6px;
      font-size: 10px;
      color: #999;
      background: transparent;
      border: 1px solid #ddd;
      border-radius: 3px;
      cursor: pointer;
    }

    .btn-clear-section:hover {
      background: #fee;
      color: #c0392b;
      border-color: #e74c3c;
    }

    .section-body {
      padding: 15px;
      display: block;
    }

    .section-body.collapsed {
      display: none;
    }

    /* Form Inputs */
    .form-group {
      margin-bottom: 14px;
      position: relative;
    }

    .form-group label {
      display: block;
      font-size: 12px;
      font-weight: 600;
      color: #7f8c8d;
      margin-bottom: 6px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .input-wrapper {
      position: relative;
      display: flex;
      align-items: stretch;
    }

    .form-control {
      flex: 1;
      width: 100%;
      padding: 10px 12px;
      padding-right: 35px;
      /* space for badge */
      border: 1px solid var(--border);
      border-radius: 4px;
      font-size: 14px;
      line-height: 1.5;
      color: #2c3e50;
      transition: all 0.2s;
      background: white;
    }

    .input-wrapper textarea.form-control {
      padding-right: 12px;
      /* Textarea suggestion button is outside or floating */
    }

    .form-control:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
      z-index: 2;
    }

    textarea.form-control {
      min-height: 70px;
      resize: vertical;
    }

    /* Input Actions (Magic Wand) */
    .input-actions {
      position: absolute;
      right: 8px;
      top: 50%;
      transform: translateY(-50%);
      display: flex;
      gap: 4px;
      z-index: 5;
    }

    textarea~.input-actions {
      top: 12px;
      transform: none;
    }

    .btn-suggest {
      background: none;
      border: none;
      cursor: pointer;
      color: #bdc3c7;
      padding: 2px;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
    }

    .btn-suggest:hover {
      color: var(--ai-color);
      background: var(--ai-bg);
      transform: scale(1.1);
    }

    .btn-suggest.loading {
      animation: spin 1s linear infinite;
      color: var(--ai-color);
      cursor: wait;
    }

    /* AI Filled State */
    .form-control.ai-filled {
      border-color: #d2b4de;
      background: linear-gradient(to right, #fff, #fcf4ff);
    }

    .ai-badge {
      position: absolute;
      right: -20px;
      /* Outside */
      top: 10px;
      font-size: 14px;
      color: var(--ai-color);
      pointer-events: none;
      animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }

    /* Selected State for highlighting */
    .form-control.field-focused {
      border-color: var(--accent);
      background: #fffcf5;
    }

    /* Footer Actions */
    .panel-footer {
      padding: 15px 20px;
      background: white;
      border-top: 1px solid var(--border);
      display: flex;
      gap: 12px;
    }

    .action-btn {
      flex: 1;
      padding: 12px;
      border: none;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      transition: all 0.2s;
    }

    .btn-export-json {
      background: #27ae60;
      color: white;
    }

    .btn-export-json:hover {
      background: #219150;
    }

    .btn-export-sheets {
      background: #fff;
      color: #27ae60;
      border: 1px solid #27ae60;
    }

    .btn-export-sheets:hover {
      background: #f0f9f4;
    }

    /* Annotations List */
    .annotations-container {
      margin-top: 20px;
    }

    .annotation-card {
      padding: 10px;
      background: white;
      border: 1px solid var(--border);
      border-left: 3px solid var(--accent);
      border-radius: 4px;
      margin-bottom: 8px;
      font-size: 12px;
      cursor: pointer;
      transition: transform 0.2s;
    }

    .annotation-card:hover {
      transform: translateX(2px);
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
    }

    .annotation-card strong {
      color: var(--secondary);
      display: block;
      margin-bottom: 4px;
    }

    .annotation-card p {
      color: #666;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* Toast & Loading */
    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(255, 255, 255, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 100;
      -webkit-backdrop-filter: blur(2px);
      backdrop-filter: blur(2px);
    }

    .spinner {
      width: 40px;
      height: 40px;
      border: 4px solid #f3f3f3;
      border-top: 4px solid var(--ai-color);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% {
        transform: rotate(0deg);
      }

      100% {
        transform: rotate(360deg);
      }
    }

    @keyframes popIn {
      0% {
        transform: scale(0);
      }

      100% {
        transform: scale(1);
      }
    }

    .toast {
      position: fixed;
      bottom: 24px;
      right: 24px;
      padding: 12px 24px;
      background: #333;
      color: white;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      z-index: 1000;
      font-size: 14px;
      display: flex;
      align-items: center;
      gap: 8px;
      animation: slideUp 0.3s ease;
    }

    .toast.error {
      background: #e74c3c;
    }

    .toast.success {
      background: #27ae60;
    }

    @keyframes slideUp {
      from {
        transform: translateY(20px);
        opacity: 0;
      }

      to {
        transform: translateY(0);
        opacity: 1;
      }
    }

    /* Scrollbar polish */
    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }

    ::-webkit-scrollbar-track {
      background: transparent;
    }

    ::-webkit-scrollbar-thumb {
      background: #cbd5e0;
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: #a0aec0;
    }
  </style>
</head>

<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useRef, useCallback } = React;

    // --- GLOBAL CONFIGURATION ---

    // Firebase Config - Updated for Firebase AI Logic / Data Connect
    const firebaseConfig = {
      apiKey: "AIzaSyAMr_rIvuAvRyvAcAsLTBOLrKiw8ikvQFQ",
      authDomain: "cerebellar-extraction.firebaseapp.com",
      projectId: "cerebellar-extraction",
      storageBucket: "cerebellar-extraction.firebasestorage.app",
      messagingSenderId: "1019192870442",
      appId: "1:1019192870442:web:0bea61ff2c9435c63c6553",
      measurementId: "G-GH46289Z2Z"
    };

    // Initialize Firebase
    if (!firebase.apps.length) {
      firebase.initializeApp(firebaseConfig);
    }
    const app = firebase.app();

    // CRITICAL: Connect to emulators BEFORE creating service instances
    // This must happen immediately after initializeApp() and before calling firebase.auth() or firebase.firestore()
    if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
      console.log('ðŸ”§ Connecting to Firebase Emulators...');
      firebase.auth().useEmulator('http://127.0.0.1:9099');
      firebase.firestore().useEmulator('127.0.0.1', 8080);
      firebase.functions().useEmulator('127.0.0.1', 5001);
      console.log('âœ… Connected to Auth Emulator: http://127.0.0.1:9099');
      console.log('âœ… Connected to Firestore Emulator: 127.0.0.1:8080');
      console.log('âœ… Connected to Functions Emulator: 127.0.0.1:5001');
    }

    // Now create service instances (these will use the emulator connections)
    const auth = firebase.auth();
    const db = firebase.firestore();
    const analytics = firebase.analytics();
    const perf = firebase.performance();

    const appId = "cerebellar-extraction";
    const apiKey = "AIzaSyA0q3GpEymeImQKwJn3g226CYLncCJaOCc"; // Gemini API key

    // Inline SVGs to replace Lucide Icons
    const Icons = {
      Wand2: (props) => <svg xmlns="http://www.w3.org/2000/svg" width={props.size || 24} height={props.size || 24} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="m21.64 3.64-1.28-1.28a1.21 1.21 0 0 0-1.72 0L2.36 18.64a1.21 1.21 0 0 0 0 1.72l1.28 1.28a1.2 1.2 0 0 0 1.72 0L21.64 5.36a1.2 1.2 0 0 0 0-1.72Z" /><path d="m14 7 3 3" /><path d="M5 6v4" /><path d="M19 14v4" /><path d="M10 2v2" /><path d="M7 8H3" /><path d="M21 16h-4" /><path d="M11 3H9" /></svg>,
      MessageSquare: (props) => <svg xmlns="http://www.w3.org/2000/svg" width={props.size || 24} height={props.size || 24} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z" /></svg>,
      FileText: (props) => <svg xmlns="http://www.w3.org/2000/svg" width={props.size || 24} height={props.size || 24} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z" /><polyline points="14 2 14 8 20 8" /><line x1="16" x2="8" y1="13" y2="13" /><line x1="16" x2="8" y1="17" y2="17" /><line x1="10" x2="8" y1="9" y2="9" /></svg>,
      Send: (props) => <svg xmlns="http://www.w3.org/2000/svg" width={props.size || 24} height={props.size || 24} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="m22 2-7 20-4-9-9-4Z" /><path d="M22 2 11 13" /></svg>,
      ChevronDown: (props) => <svg xmlns="http://www.w3.org/2000/svg" width={props.size || 24} height={props.size || 24} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="m6 9 6 6 6-6" /></svg>,
      ChevronRight: (props) => <svg xmlns="http://www.w3.org/2000/svg" width={props.size || 24} height={props.size || 24} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="m9 18 6-6-6-6" /></svg>,
      Quote: (props) => <svg xmlns="http://www.w3.org/2000/svg" width={props.size || 24} height={props.size || 24} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="M3 21c3 0 7-1 7-8V5c0-1.25-.756-2.017-2-2H4c-1.25 0-2 .75-2 1.972V11c0 1.25.75 2 2 2 1 0 1 0 1 1v1c0 1-1 2-2 2s-1 .008-1 1.031V20c0 1 0 1 1 1z" /><path d="M15 21c3 0 7-1 7-8V5c0-1.25-.757-2.017-2-2h-4c-1.25 0-2 .75-2 1.972V11c0 1.25.75 2 2 2 1 0 1 0 1 1v1c0 1-1 2-2 2s-1 .008-1 1.031V20c0 1 0 1 1 1z" /></svg>,
      Activity: (props) => <svg xmlns="http://www.w3.org/2000/svg" width={props.size || 24} height={props.size || 24} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="M22 12h-4l-3 9L9 3l-3 9H2" /></svg>,
      Cloud: (props) => <svg xmlns="http://www.w3.org/2000/svg" width={props.size || 24} height={props.size || 24} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="M17.5 19c0-1.7-1.3-3-3-3h-11a3 3 0 0 1-.3-6 5 5 0 0 1 9.7-1.5 4 4 0 0 1 7.9 2.3 2.2 2.2 0 0 1 .2.9 2.5 2.5 0 0 1-2.5 2.3Z" /></svg>,
      Check: (props) => <svg xmlns="http://www.w3.org/2000/svg" width={props.size || 24} height={props.size || 24} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="M20 6 9 17l-5-5" /></svg>,
      Table: (props) => <svg xmlns="http://www.w3.org/2000/svg" width={props.size || 24} height={props.size || 24} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="M3 3h18v18H3z" /><path d="M3 9h18" /><path d="M3 15h18" /><path d="M12 3v18" /></svg>,
      Image: (props) => <svg xmlns="http://www.w3.org/2000/svg" width={props.size || 24} height={props.size || 24} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><rect width="18" height="18" x="3" y="3" rx="2" ry="2" /><circle cx="9" cy="9" r="2" /><path d="m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21" /></svg>
    };

    const FIELD_MAP = {
      "Study ID": "study_id",
      "Authors": "authors",
      "Year": "year",
      "Title": "title",
      "Sample Size": "population.sample_size",
      "Mean Age": "population.mean_age",
      "Inclusion Criteria": "population.inclusion_criteria",
      "Intervention": "intervention.procedure",
      "Intervention Timing": "intervention.timing_hours",
      "Intervention Technique": "intervention.technique",
      "Comparator": "comparator",
      "Mortality": "outcomes.mortality",
      "mRS Outcome": "outcomes.mRS_favorable",
      "Complications": "outcomes.complications",
      "Length of Stay": "outcomes.length_of_stay",
      "Follow-up Duration": "timing.follow_up_duration",
      "Study Design": "study_design",
      "Newcastle-Ottawa Score": "newcastle_ottawa_score"
    };

    const GEMINI_SCHEMA = {
      type: "OBJECT",
      properties: {
        study_id: { type: "STRING", description: "First author last name + year e.g. Smith2023" },
        authors: { type: "STRING", description: "Authors string e.g. Smith et al." },
        year: { type: "STRING" },
        title: { type: "STRING" },
        population: {
          type: "OBJECT",
          properties: {
            sample_size: { type: "STRING" },
            mean_age: { type: "STRING" },
            inclusion_criteria: { type: "STRING" },
          }
        },
        intervention: {
          type: "OBJECT",
          properties: {
            procedure: { type: "STRING" },
            timing_hours: { type: "STRING" },
            technique: { type: "STRING" }
          }
        },
        outcomes: {
          type: "OBJECT",
          properties: {
            mortality: { type: "STRING" },
            mRS_favorable: { type: "STRING" },
            complications: { type: "STRING" },
            length_of_stay: { type: "STRING" }
          }
        },
        study_design: { type: "STRING" },
      }
    };

    const QUICK_PROMPTS = [
      "Summarize key findings",
      "Assess risk of bias",
      "List exclusion criteria",
      "Describe the intervention"
    ];

    // --- GLOBAL UTILS ---
    const cleanExtractedText = (text) => {
      if (!text) return "";
      return text.replace(/(\w)-\n(\w)/g, '$1$2').replace(/\n/g, ' ').replace(/\s+/g, ' ').trim();
    };

    /**
     * Convert PDF coordinates to canvas pixel coordinates
     * PDF coordinates: origin at bottom-left, y increases upward
     * Canvas coordinates: origin at top-left, y increases downward
     */
    const pdfToCanvasCoords = (pdfX, pdfY, pdfWidth, pdfHeight, viewport) => {
      // Apply viewport transformation
      const [a, b, c, d, e, f] = viewport.transform;

      // PDF coords to canvas coords using transformation matrix
      // For standard viewport: x' = scale * x, y' = height - (scale * y)
      const canvasX = pdfX * viewport.scale;
      const canvasY = viewport.height - (pdfY * viewport.scale);
      const canvasWidth = pdfWidth * viewport.scale;
      const canvasHeight = pdfHeight * viewport.scale;

      return {
        left: canvasX,
        top: canvasY - canvasHeight, // Adjust for height since y is bottom of rect in PDF
        width: canvasWidth,
        height: canvasHeight
      };
    };

    /**
     * Convert citation highlight from PDF space to canvas space
     */
    const convertCitationHighlight = (citation, viewport) => {
      return {
        ...citation,
        canvasRect: pdfToCanvasCoords(
          citation.x,
          citation.y,
          citation.width,
          citation.height,
          viewport
        )
      };
    };

    /**
     * Call Claude API with native citations enabled via Firebase Callable Function
     * Uses httpsCallable for automatic auth handling and type-safe serialization
     */
    const getFunctions = () => {
      // Get Firebase Functions instance (uses default region us-central1)
      return firebase.functions();
    };

    const callClaudeWithCitations = async (pdfText, positions = null, extractionPrompt = null) => {
      try {
        const functions = getFunctions();
        const extractCitations = functions.httpsCallable('extractCitations');

        // Call the callable function - auth token automatically included
        const result = await extractCitations({
          pdfText,
          positions,
          extractionPrompt
        });

        return result.data; // Callable functions return {data: ...}
      } catch (error) {
        // Firebase callable errors have code and message
        console.warn('Citation API error:', error.code, error.message);
        // Return null to allow fallback to Gemini
        return null;
      }
    };

    /**
     * Extract text with positions from PDF pages
     * Returns array of position objects for citation mapping
     */
    const extractPdfPositions = async (pdfDoc) => {
      const positions = [];
      let globalCharIndex = 0;

      for (let pageNum = 1; pageNum <= pdfDoc.numPages; pageNum++) {
        const page = await pdfDoc.getPage(pageNum);
        const textContent = await page.getTextContent();

        for (const item of textContent.items) {
          if (!item.str) continue;

          const text = item.str;
          const startChar = globalCharIndex;
          const endChar = globalCharIndex + text.length;

          positions.push({
            text,
            startChar,
            endChar,
            x: item.transform[4],
            y: item.transform[5],
            width: item.width || 0,
            height: item.height || 10,
            page: pageNum,
          });

          globalCharIndex = endChar + 1; // +1 for space separator
        }

        globalCharIndex += 2; // Page separator
      }

      return positions;
    };

    const callGemini = async (prompt, schema = null) => {
      const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-3-pro-preview:generateContent?key=${apiKey}`;

      const payload = {
        contents: [{ parts: [{ text: prompt }] }],
      };

      if (schema) {
        payload.generationConfig = { responseMimeType: "application/json", responseSchema: schema };
      }

      const response = await fetch(apiUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });

      if (!response.ok) throw new Error("API Error");
      const result = await response.json();
      return result.candidates?.[0]?.content?.parts?.[0]?.text;
    };

    // --- COMPONENTS ---

    function App() {
      // PDF State
      const [pdfFile, setPdfFile] = useState(null);  // Filename string
      const [pdfFileObject, setPdfFileObject] = useState(null);  // Actual File object for Cloud Functions
      const [pdfDoc, setPdfDoc] = useState(null);
      const [pageNum, setPageNum] = useState(1);
      const [numPages, setNumPages] = useState(0);
      const [pageOneText, setPageOneText] = useState('');
      const [availablePDFs, setAvailablePDFs] = useState([]);
      const [selectedPDFDropdown, setSelectedPDFDropdown] = useState('');

      // Extraction State
      const [highlights, setHighlights] = useState({}); // Changed to object: { [pdfFilename]: [highlights] }
      const [currentField, setCurrentField] = useState('');
      const [selectionMode, setSelectionMode] = useState(false);
      const [aiFilledFields, setAiFilledFields] = useState(new Set());

      // Citation State (from Claude Native Citations)
      const [citations, setCitations] = useState([]);
      const [activeCitation, setActiveCitation] = useState(null);
      const [citationHighlights, setCitationHighlights] = useState([]);

      // Firebase State
      const [user, setUser] = useState(null);
      const [saving, setSaving] = useState(false);

      const [extractedData, setExtractedData] = useState({
        study_id: '', authors: '', year: '', title: '',
        population: { sample_size: '', mean_age: '', diagnosis: 'Space-occupying cerebellar infarction', inclusion_criteria: '' },
        intervention: { procedure: '', timing_hours: '', technique: '', additional_details: '' },
        comparator: '',
        outcomes: { mortality: '', mRS_favorable: '', complications: '', length_of_stay: '' },
        timing: { follow_up_duration: '' },
        study_design: '', newcastle_ottawa_score: ''
      });

      // UI State
      const [toast, setToast] = useState(null);
      const [isLoading, setIsLoading] = useState(false);
      const [activeTab, setActiveTab] = useState('extract'); // 'extract', 'tables', 'figures', or 'chat'
      const [chatMessages, setChatMessages] = useState([]); // Array of {role, text}
      const [extractedTables, setExtractedTables] = useState([]);
      const [extractedFigures, setExtractedFigures] = useState([]);

      // QuickCritique Validation State
      const [validationErrors, setValidationErrors] = useState([]);
      const [validationWarnings, setValidationWarnings] = useState([]);
      const [isValidating, setIsValidating] = useState(false);
      const [lastValidationTime, setLastValidationTime] = useState(null);
      const validationTimeoutRef = React.useRef(null);

      const showToast = (message, type = 'success') => {
        setToast({ message, type });
        setTimeout(() => setToast(null), 3000);
      };

      // --- QUICKCRITIQUE VALIDATION ---
      // Calls the Genkit quickCritique flow for real-time validation
      const runQuickCritique = async (dataToValidate) => {
        try {
          // Try Genkit Reflection API (runs on port 3100 or 3101)
          const genkitPorts = [3100, 3101];
          let response = null;

          for (const port of genkitPorts) {
            try {
              const res = await fetch(`http://localhost:${port}/api/runAction`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  key: '/flow/quickCritique',
                  input: { extractedData: dataToValidate }
                })
              });
              if (res.ok) {
                response = await res.json();
                break;
              }
            } catch (e) {
              // Try next port
            }
          }

          if (!response) {
            console.warn('QuickCritique: Genkit server not available');
            return null;
          }

          return response.result;
        } catch (error) {
          console.error('QuickCritique error:', error);
          return null;
        }
      };

      // Debounced validation - runs 1 second after user stops typing
      const triggerValidation = React.useCallback((data) => {
        // Clear any pending validation
        if (validationTimeoutRef.current) {
          clearTimeout(validationTimeoutRef.current);
        }

        // Schedule new validation
        validationTimeoutRef.current = setTimeout(async () => {
          setIsValidating(true);
          try {
            const result = await runQuickCritique(data);
            if (result) {
              setValidationErrors(result.errors || []);
              setValidationWarnings(result.warnings || []);
              setLastValidationTime(new Date().toLocaleTimeString());

              // Show toast for critical errors
              if (result.errors && result.errors.length > 0) {
                showToast(`âš ï¸ ${result.errors.length} validation issue(s) found`, 'error');
              }
            }
          } catch (e) {
            console.error('Validation failed:', e);
          } finally {
            setIsValidating(false);
          }
        }, 1000); // 1 second debounce
      }, []);

      // --- FIREBASE AUTH ---
      const signInWithGoogle = async () => {
        const provider = new firebase.auth.GoogleAuthProvider();
        try {
          await auth.signInWithPopup(provider);
          analytics.logEvent('login', { method: 'google' });
          showToast("Signed in successfully!");
        } catch (error) {
          console.error("Auth Error:", error);
          showToast("Sign in failed", "error");
        }
      };

      const signOut = () => {
        auth.signOut();
        showToast("Signed out");
      };

      useEffect(() => {
        if (!auth) return;
        const unsubscribe = auth.onAuthStateChanged(user => {
          setUser(user);
          if (!user) {
            // Optional: Auto-signin anonymously if you want to allow guest access
            // auth.signInAnonymously().catch(console.error);
          }
        });
        return unsubscribe;
      }, []);

      // Load available PDFs from pdfs.json
      useEffect(() => {
        fetch('pdf/pdfs.json')
          .then(res => res.json())
          .then(data => setAvailablePDFs(data.pdfs || []))
          .catch(err => console.error('Failed to load PDFs:', err));
      }, []);

      // --- FIREBASE SYNC ---
      // 1. Load initial data
      useEffect(() => {
        if (!user || !db) return;
        const docRef = db.collection('artifacts').doc(appId).collection('users').doc(user.uid).collection('data').doc('current_extraction');

        // Initial Load
        docRef.get().then(doc => {
          if (doc.exists) {
            const data = doc.data();
            if (data.extractedData) {
              setExtractedData(data.extractedData);
              setAiFilledFields(new Set(data.aiFilledFields || []));
              setHighlights(data.highlights || {}); // Load per-PDF highlights object
              showToast("Cloud data loaded");
            }
          }
        }).catch(console.error);

        return () => { };
      }, [user]);

      // 2. Auto-save on change (Debounced)
      useEffect(() => {
        if (!user || !db) return;
        const docRef = db.collection('artifacts').doc(appId).collection('users').doc(user.uid).collection('data').doc('current_extraction');

        setSaving(true);
        const handler = setTimeout(() => {
          docRef.set({
            extractedData,
            highlights,
            aiFilledFields: Array.from(aiFilledFields),
            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
          }, { merge: true }).then(() => {
            setSaving(false);
          }).catch(err => {
            console.error("Save failed", err);
            setSaving(false);
          });
        }, 1000);

        return () => clearTimeout(handler);
      }, [extractedData, highlights, user, aiFilledFields]);

      // 3. Document Size Monitoring (warn at 80% of 1MB Firestore limit)
      useEffect(() => {
        const documentData = {
          extractedData,
          highlights,
          aiFilledFields: Array.from(aiFilledFields)
        };
        const sizeEstimate = new Blob([JSON.stringify(documentData)]).size;
        const sizeKB = Math.round(sizeEstimate / 1024);
        const sizeMB = (sizeEstimate / (1024 * 1024)).toFixed(2);

        // Log size for debugging
        console.log(`Firestore document size: ${sizeKB} KB (${sizeMB} MB)`);

        // Warn at 80% of 1MB limit (819,200 bytes)
        if (sizeEstimate > 800_000) {
          const pdfCount = Object.keys(highlights).length;
          const totalHighlights = Object.values(highlights).reduce((sum, arr) => sum + arr.length, 0);
          console.warn(`âš ï¸ Document size: ${sizeKB} KB - approaching 1MB Firestore limit`);
          console.warn(`   PDFs with highlights: ${pdfCount}, Total highlights: ${totalHighlights}`);
          showToast(`âš ï¸ Storage: ${sizeKB} KB / 1024 KB - Consider archiving old PDFs`, 'warning');
        }
      }, [extractedData, highlights, aiFilledFields]);


      const handleFileUpload = async (file) => {
        if (!file) return;
        setIsLoading(true);
        const reader = new FileReader();
        reader.onload = async (e) => {
          try {
            const arrayBuffer = e.target.result;
            setPdfFile(file.name);
            setPdfFileObject(file);  // Store actual File object for Cloud Functions
            setPdfDoc(null);
            setChatMessages([{ role: 'system', text: 'Document loaded. You can now chat with the abstract.' }]);

            const loadingTask = pdfjsLib.getDocument({ data: arrayBuffer });
            const pdf = await loadingTask.promise;
            setPdfDoc(pdf);
            setNumPages(pdf.numPages);
            setPageNum(1);

            try {
              const page = await pdf.getPage(1);
              const textContent = await page.getTextContent();
              const pageText = textContent.items.map(item => item.str).join(' ');
              setPageOneText(pageText);
            } catch (err) { console.error("Text extraction warning", err); }

            showToast("PDF loaded successfully");
            analytics.logEvent('pdf_uploaded', { file_name: file.name, num_pages: pdf.numPages });
          } catch (error) {
            showToast("Error loading PDF", 'error');
            console.error(error);
          } finally {
            setIsLoading(false);
          }
        };
        reader.readAsArrayBuffer(file);
      };

      const handlePDFDropdownChange = async (filename) => {
        if (!filename) return;
        setSelectedPDFDropdown(filename);
        setIsLoading(true);

        try {
          const response = await fetch(`pdf/${filename}`);
          const arrayBuffer = await response.arrayBuffer();
          const blob = new Blob([arrayBuffer], { type: 'application/pdf' });
          const file = new File([blob], filename, { type: 'application/pdf' });

          setPdfFile(file.name);
          setPdfFileObject(file);  // Store actual File object for Cloud Functions
          setPdfDoc(null);
          setChatMessages([{ role: 'system', text: 'Document loaded from library. You can now chat with the paper.' }]);

          const loadingTask = pdfjsLib.getDocument({ data: arrayBuffer });
          const pdf = await loadingTask.promise;
          setPdfDoc(pdf);
          setNumPages(pdf.numPages);
          setPageNum(1);

          try {
            const page = await pdf.getPage(1);
            const textContent = await page.getTextContent();
            const pageText = textContent.items.map(item => item.str).join(' ');
            setPageOneText(pageText);
          } catch (err) { console.error("Text extraction warning", err); }

          showToast(`${filename} loaded successfully`);
          analytics.logEvent('pdf_loaded_from_library', { file_name: filename, num_pages: pdf.numPages });
        } catch (error) {
          showToast("Error loading PDF from library", 'error');
          console.error(error);
          setSelectedPDFDropdown('');
        } finally {
          setIsLoading(false);
        }
      };

      const updateField = (path, value, isAi = false) => {
        const keys = path.split('.');
        setExtractedData(prev => {
          const next = JSON.parse(JSON.stringify(prev));
          let current = next;
          for (let i = 0; i < keys.length - 1; i++) current = current[keys[i]];
          current[keys[keys.length - 1]] = value;

          // Trigger debounced validation after state update
          triggerValidation(next);

          return next;
        });

        if (isAi) {
          setAiFilledFields(prev => new Set(prev).add(path));
        } else {
          const newSet = new Set(aiFilledFields);
          newSet.delete(path);
          setAiFilledFields(newSet);
        }
      };

      // --- FEATURE 0: CLAUDE CITATION EXTRACTION ---
      const handleClaudeCitationExtract = async () => {
        if (!pdfDoc) return showToast("No PDF loaded", "error");
        setIsLoading(true);

        try {
          // Extract full text with positions
          const positions = await extractPdfPositions(pdfDoc);
          const fullText = positions.map(p => p.text).join(' ');

          showToast("Extracting with Claude citations...");

          const result = await callClaudeWithCitations(fullText, positions);

          if (result && result.success) {
            // Set citations for display
            setCitations(result.citations || []);
            setCitationHighlights(result.citations || []);

            showToast(`âœ¨ Found ${result.citations?.length || 0} verified citations!`);
            analytics.logEvent('claude_citation_extraction', { citationCount: result.citations?.length || 0 });
          } else {
            showToast("Citation extraction unavailable, using Gemini fallback", "error");
            // Fall back to Gemini
            await handleAiAutofill();
          }
        } catch (e) {
          console.error('Citation extraction error:', e);
          showToast("Citation extraction failed", "error");
        } finally {
          setIsLoading(false);
        }
      };

      // --- FEATURE 1: AUTO-FILL ENTIRE FORM ---
      const handleAiAutofill = async () => {
        if (!pageOneText) return showToast("No text available from abstract", "error");
        setIsLoading(true);

        const systemPrompt = `You are an expert systematic reviewer. Extract data from this medical study abstract into the exact JSON structure provided. 
                              Be precise. If data is missing, use empty strings. 
                              Return ONLY valid JSON. 
                              
                              Abstract: ${pageOneText}`;

        try {
          const jsonText = await callGemini(systemPrompt, GEMINI_SCHEMA);
          if (!jsonText) throw new Error("No data returned");

          const aiData = JSON.parse(jsonText);
          const newAiFields = new Set(aiFilledFields);

          setExtractedData(prev => {
            const next = JSON.parse(JSON.stringify(prev));

            const safeUpdate = (obj, targetObj, prefix) => {
              Object.keys(obj).forEach(k => {
                if (typeof obj[k] === 'object' && obj[k] !== null) {
                  safeUpdate(obj[k], targetObj[k], prefix ? `${prefix}.${k}` : k);
                } else if (obj[k] && targetObj.hasOwnProperty(k)) {
                  targetObj[k] = obj[k];
                  newAiFields.add(prefix ? `${prefix}.${k}` : k);
                }
              });
            }

            // Map specific top level fields manually to be safe
            if (aiData.study_id) { next.study_id = aiData.study_id; newAiFields.add('study_id'); }
            if (aiData.authors) { next.authors = aiData.authors; newAiFields.add('authors'); }
            if (aiData.year) { next.year = aiData.year; newAiFields.add('year'); }
            if (aiData.title) { next.title = aiData.title; newAiFields.add('title'); }
            if (aiData.study_design) { next.study_design = aiData.study_design; newAiFields.add('study_design'); }

            // Map nested
            if (aiData.population) safeUpdate(aiData.population, next.population, 'population');
            if (aiData.intervention) safeUpdate(aiData.intervention, next.intervention, 'intervention');
            if (aiData.outcomes) safeUpdate(aiData.outcomes, next.outcomes, 'outcomes');

            return next;
          });

          setAiFilledFields(newAiFields);
          showToast("âœ¨ Data extracted from abstract!");
          analytics.logEvent('ai_extraction_completed');
        } catch (e) {
          console.error(e);
          showToast("AI Extraction failed", "error");
        } finally {
          setIsLoading(false);
        }
      };

      // --- FEATURE 2: SMART FIELD SUGGEST ---
      const handleSmartSuggest = async (fieldLabel, path) => {
        if (!pageOneText) return showToast("No text available", "error");

        const prompt = `Context: ${pageOneText}
          
          Task: Identify and extract the "${fieldLabel}" from the medical study abstract above.
          Return ONLY the extracted value as a plain text string. Do not include label names or markdown. 
          If not found, return "Not found".`;

        try {
          const result = await callGemini(prompt);
          if (result && !result.toLowerCase().includes("not found")) {
            updateField(path, result.trim(), true);
            showToast(`âœ¨ Found ${fieldLabel}`);
          } else {
            showToast(`Could not find ${fieldLabel}`, "error");
          }
        } catch (e) {
          console.error(e);
          showToast("Suggestion failed", "error");
        }
      };

      // --- FEATURE 3: CHAT ASSISTANT ---
      const handleSendMessage = async (text) => {
        if (!text.trim()) return;

        const newMessage = { role: 'user', text };
        setChatMessages(prev => [...prev, newMessage]);

        if (!pageOneText) {
          setChatMessages(prev => [...prev, { role: 'assistant', text: 'Please upload a PDF with extractable text first.' }]);
          return;
        }

        const prompt = `Context (Abstract of a medical study):
          ${pageOneText}
          
          User Question: ${text}
          
          Answer as a helpful medical research assistant. Keep it concise and grounded in the context provided.`;

        try {
          const response = await callGemini(prompt);
          setChatMessages(prev => [...prev, { role: 'assistant', text: response }]);
        } catch (e) {
          setChatMessages(prev => [...prev, { role: 'assistant', text: 'Sorry, I encountered an error processing your request.' }]);
        }
      };

      // --- FEATURE 4: QUALITY CHECK ---
      const handleQualityCheck = async () => {
        if (!pageOneText) return showToast("No text available", "error");
        setIsLoading(true);

        const prompt = `Context: ${pageOneText}
          
          Task: Evaluate the risk of bias and quality of this study based on the abstract. 
          1. Identify the study design (e.g. RCT, Cohort).
          2. Estimate a Newcastle-Ottawa Score (0-9) if observational, or Jadad Score (0-5) if RCT.
          3. Return a short 1-sentence reasoning.
          
          Return Format: "Score: X/9 (Reasoning...)"`;

        try {
          const result = await callGemini(prompt);
          updateField('newcastle_ottawa_score', result);
          showToast("âœ¨ Quality assessed!");
        } catch (e) {
          showToast("Assessment failed", "error");
        } finally {
          setIsLoading(false);
        }
      };

      // --- FEATURE 5: CITATION GENERATOR ---
      const handleGenerateCitation = async () => {
        if (!extractedData.title && !pageOneText) return showToast("No title or text available", "error");
        setIsLoading(true);

        const context = extractedData.title ? `Title: ${extractedData.title}, Authors: ${extractedData.authors}, Year: ${extractedData.year}` : `Abstract: ${pageOneText}`;

        const prompt = `Generate a citation in APA 7th format for this study based on the following info: ${context}. Return ONLY the citation string.`;

        try {
          const result = await callGemini(prompt);
          // Just appending it to the chat for now as a useful place to show it
          setChatMessages(prev => [...prev, { role: 'assistant', text: `ðŸ“ Generated Citation:\n${result}` }]);
          setActiveTab('chat');
          showToast("Citation generated in Chat!");
        } catch (e) {
          showToast("Citation generation failed", "error");
        } finally {
          setIsLoading(false);
        }
      };

      const addHighlight = (rect, rawText) => {
        if (!pdfFile) return; // Ensure we have a PDF loaded
        const text = cleanExtractedText(rawText);
        const highlight = {
          id: Date.now(),
          page: pageNum,
          field: currentField,
          rect: rect,
          text: text
        };
        // Add highlight to current PDF's highlight array
        setHighlights(prev => ({
          ...prev,
          [pdfFile]: [...(prev[pdfFile] || []), highlight]
        }));

        const dataPath = FIELD_MAP[currentField];
        if (dataPath) {
          const keys = dataPath.split('.');
          let currentVal = extractedData;
          keys.forEach(k => currentVal = currentVal[k]);
          const newValue = currentVal ? `${currentVal}; ${text}` : text;
          updateField(dataPath, newValue);
          showToast(`Captured: ${currentField}`);
        }
        setSelectionMode(false);
      };

      const clearHighlightsForPDF = () => {
        if (!pdfFile) {
          showToast('No PDF loaded', 'error');
          return;
        }
        const count = (highlights[pdfFile] || []).length;
        if (count === 0) {
          showToast('No highlights to clear', 'info');
          return;
        }
        if (!window.confirm(`Delete ${count} highlight${count !== 1 ? 's' : ''} for "${pdfFile}"?\n\nThis action cannot be undone.`)) {
          return;
        }
        setHighlights(prev => {
          const updated = { ...prev };
          delete updated[pdfFile];
          return updated;
        });
        showToast(`Cleared ${count} highlight${count !== 1 ? 's' : ''}`, 'success');
        analytics.logEvent('highlights_cleared', { pdf_file: pdfFile, count });
      };

      const handleExport = () => {
        const blob = new Blob([JSON.stringify(extractedData, null, 2)], { type: 'application/json' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = `${extractedData.study_id || 'data'}.json`;
        a.click();
        analytics.logEvent('data_exported', { study_id: extractedData.study_id });
      };

      if (!user) {
        return (
          <div style={{ display: 'flex', height: '100vh', justifyContent: 'center', alignItems: 'center', background: '#eef2f5' }}>
            <div style={{ padding: 40, background: 'white', borderRadius: 8, boxShadow: '0 4px 12px rgba(0,0,0,0.1)', textAlign: 'center' }}>
              <h2 style={{ marginBottom: 20, color: '#2c3e50' }}>Cerebellar Extraction Tool</h2>
              <p style={{ marginBottom: 30, color: '#7f8c8d' }}>Please sign in to access your extractions.</p>
              <button onClick={signInWithGoogle} style={{ padding: '12px 24px', background: '#4285F4', color: 'white', border: 'none', borderRadius: 4, cursor: 'pointer', fontWeight: 600, fontSize: 16 }}>
                Sign in with Google
              </button>
            </div>
          </div>
        );
      }

      return (
        <div className="app">
          {isLoading && <div className="loading-overlay"><div className="spinner"></div></div>}

          <div style={{ position: 'absolute', top: 10, right: 10, zIndex: 1000 }}>
            <button onClick={signOut} style={{ padding: '6px 12px', background: '#e74c3c', color: 'white', border: 'none', borderRadius: 4, cursor: 'pointer', fontSize: 12 }}>
              Sign Out
            </button>
          </div>

          <PDFPanel
            pdfFile={pdfFile}
            pdfDoc={pdfDoc}
            pageNum={pageNum}
            numPages={numPages}
            highlights={highlights}
            currentField={currentField}
            selectionMode={selectionMode}
            onFileUpload={handleFileUpload}
            onPageChange={setPageNum}
            onFieldSelect={setCurrentField}
            onSelectionModeToggle={setSelectionMode}
            onAddHighlight={addHighlight}
            onClearHighlights={clearHighlightsForPDF}
            citationHighlights={citationHighlights}
            activeCitation={activeCitation}
            onCitationClick={(cit) => {
              setActiveCitation(cit);
              if (cit.page !== pageNum) setPageNum(cit.page);
            }}
            availablePDFs={availablePDFs}
            selectedPDFDropdown={selectedPDFDropdown}
            onPDFDropdownChange={handlePDFDropdownChange}
          />

          <div className="extraction-panel">
            <div className="extraction-header">
              <div className="header-title-row">
                <h2>ðŸ“‹ Extraction Assistant</h2>
                {saving ? (
                  <span className="save-status saving"><Icons.Cloud size={12} /> Saving...</span>
                ) : (
                  <span className="save-status saved"><Icons.Check size={12} /> Saved</span>
                )}
              </div>
              {activeTab === 'extract' && (
                <select
                  value={currentField}
                  onChange={e => setCurrentField(e.target.value)}
                  style={{
                    padding: '6px 10px',
                    background: 'white',
                    border: '1px solid var(--border)',
                    borderRadius: '4px',
                    fontSize: '12px',
                    marginBottom: '10px',
                    width: '100%',
                    cursor: 'pointer'
                  }}
                >
                  <option value="">Jump to Field...</option>
                  {Object.keys(FIELD_MAP).map(fieldName => (
                    <option key={fieldName} value={fieldName}>{fieldName}</option>
                  ))}
                </select>
              )}

              <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: 10, gap: 8 }}>
                {activeTab === 'extract' && (
                  <>
                    <button
                      className="btn-ai-magic"
                      onClick={handleClaudeCitationExtract}
                      disabled={!pdfDoc}
                      style={{ background: 'linear-gradient(135deg, #6366f1, #8b5cf6)' }}
                      title="Extract with verified source citations"
                    >
                      <Icons.Quote size={12} /> Citations
                    </button>
                    <button className="btn-ai-magic" onClick={handleAiAutofill} disabled={!pageOneText}>
                      <Icons.Wand2 size={12} /> Auto-Fill
                    </button>
                  </>
                )}
              </div>
              <div className="panel-tabs">
                <button className={`tab-btn ${activeTab === 'extract' ? 'active' : ''}`} onClick={() => setActiveTab('extract')}>
                  <Icons.FileText size={14} style={{ marginRight: 4, display: 'inline', verticalAlign: 'middle' }} /> Form
                </button>
                <button className={`tab-btn ${activeTab === 'tables' ? 'active' : ''}`} onClick={() => setActiveTab('tables')}>
                  <Icons.Table size={14} style={{ marginRight: 4, display: 'inline', verticalAlign: 'middle' }} /> Tables
                </button>
                <button className={`tab-btn ${activeTab === 'figures' ? 'active' : ''}`} onClick={() => setActiveTab('figures')}>
                  <Icons.Image size={14} style={{ marginRight: 4, display: 'inline', verticalAlign: 'middle' }} /> Figures
                </button>
                <button className={`tab-btn ${activeTab === 'chat' ? 'active' : ''}`} onClick={() => setActiveTab('chat')}>
                  <Icons.MessageSquare size={14} style={{ marginRight: 4, display: 'inline', verticalAlign: 'middle' }} /> Chat
                </button>
              </div>
            </div>

            <div className="extraction-content">
              {activeTab === 'extract' ? (
                <ExtractionForm
                  data={extractedData}
                  highlights={highlights}
                  pdfFile={pdfFile}
                  currentField={currentField}
                  aiFilledFields={aiFilledFields}
                  onUpdate={updateField}
                  onFieldSelect={setCurrentField}
                  onExport={handleExport}
                  onGoToHighlight={setPageNum}
                  onSmartSuggest={handleSmartSuggest}
                  onQualityCheck={handleQualityCheck}
                  onGenerateCitation={handleGenerateCitation}
                  citations={citations}
                  activeCitation={activeCitation}
                  onCitationSelect={(cit) => {
                    setActiveCitation(cit);
                    if (cit.page) setPageNum(cit.page);
                  }}
                  validationErrors={validationErrors}
                  validationWarnings={validationWarnings}
                  isValidating={isValidating}
                  lastValidationTime={lastValidationTime}
                />
              ) : activeTab === 'tables' ? (
                <TablesInterface
                  pdfDoc={pdfDoc}
                  pdfFile={pdfFileObject}
                  tables={extractedTables}
                  onTablesExtracted={setExtractedTables}
                />
              ) : activeTab === 'figures' ? (
                <FiguresInterface
                  pdfDoc={pdfDoc}
                  pdfFile={pdfFileObject}
                  figures={extractedFigures}
                  onFiguresExtracted={setExtractedFigures}
                />
              ) : (
                <ChatInterface
                  messages={chatMessages}
                  onSendMessage={handleSendMessage}
                  hasContext={!!pageOneText}
                />
              )}
            </div>
          </div>

          {toast && <div className={`toast ${toast.type}`}>{toast.message}</div>}
        </div>
      );
    }

    // --- SUB-COMPONENTS ---

    function ChatInterface({ messages, onSendMessage, hasContext }) {
      const [input, setInput] = useState('');
      const msgEndRef = useRef(null);

      const send = (e) => {
        e.preventDefault();
        if (input.trim()) {
          onSendMessage(input);
          setInput('');
        }
      };

      const handleQuickPrompt = (text) => {
        onSendMessage(text);
      };

      useEffect(() => {
        msgEndRef.current?.scrollIntoView({ behavior: 'smooth' });
      }, [messages]);

      return (
        <div className="chat-container">
          <div className="chat-messages">
            {messages.map((m, i) => (
              <div key={i} className={`message ${m.role}`}>
                {m.role === 'assistant' && <div style={{ fontWeight: 'bold', marginBottom: 4, fontSize: 11, color: '#8e44ad' }}>GEMINI</div>}
                {m.text}
              </div>
            ))}
            <div ref={msgEndRef} />
          </div>

          {hasContext && (
            <div className="quick-prompts">
              {QUICK_PROMPTS.map(p => (
                <button key={p} className="prompt-pill" onClick={() => handleQuickPrompt(p)}>
                  {p}
                </button>
              ))}
            </div>
          )}

          <form className="chat-input-area" onSubmit={send}>
            <input
              className="chat-input"
              placeholder={hasContext ? "Ask about the paper..." : "Upload a PDF first..."}
              value={input}
              onChange={e => setInput(e.target.value)}
              disabled={!hasContext}
            />
            <button type="submit" className="btn-send" disabled={!hasContext}>
              <Icons.Send size={16} />
            </button>
          </form>
        </div>
      );
    }

    function TablesInterface({ pdfDoc, pdfFile, tables, onTablesExtracted }) {
      const [isExtracting, setIsExtracting] = useState(false);
      const [error, setError] = useState(null);
      const [expandedTable, setExpandedTable] = useState(null);

      const extractTables = async () => {
        if (!pdfFile) {
          setError('Please upload a PDF file first');
          return;
        }
        setIsExtracting(true);
        setError(null);

        try {
          // Convert PDF to base64
          const arrayBuffer = await pdfFile.arrayBuffer();
          const base64 = btoa(
            new Uint8Array(arrayBuffer).reduce((data, byte) => data + String.fromCharCode(byte), '')
          );

          // Call Python Cloud Function
          const extractTablesEnhanced = firebase.functions().httpsCallable('extract_tables_enhanced');

          // Use direct HTTP call since Python functions use on_request
          const response = await fetch('http://127.0.0.1:5001/cerebellar-sdc/us-central1/extract_tables_enhanced', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ pdf_base64: base64, detect_captions: true })
          });

          const result = await response.json();

          if (result.success) {
            const extractedTables = result.tables.map((table, idx) => ({
              id: idx + 1,
              page: table.page,
              caption: table.caption || `Table ${table.table_index + 1}`,
              headers: table.headers,
              rows: table.rows,
              raw: table.raw,
              rowCount: table.row_count,
              colCount: table.column_count
            }));
            onTablesExtracted(extractedTables);
            console.log(`âœ… Extracted ${extractedTables.length} tables`);
          } else {
            throw new Error(result.error || 'Table extraction failed');
          }
        } catch (error) {
          console.error('Table extraction error:', error);
          setError(error.message);
        } finally {
          setIsExtracting(false);
        }
      };

      return (
        <div style={{ padding: '20px' }}>
          <div style={{ marginBottom: '20px' }}>
            <h3 style={{ marginBottom: '10px', color: 'var(--secondary)' }}>ðŸ“Š Table Extraction</h3>
            <p style={{ fontSize: '13px', color: '#7f8c8d', marginBottom: '15px' }}>
              Extract structured tables from the PDF with automatic caption detection.
            </p>
            <button
              onClick={extractTables}
              disabled={!pdfFile || isExtracting}
              style={{
                padding: '10px 20px',
                background: 'var(--primary)',
                color: 'white',
                border: 'none',
                borderRadius: '4px',
                cursor: pdfFile && !isExtracting ? 'pointer' : 'not-allowed',
                opacity: pdfFile && !isExtracting ? 1 : 0.6
              }}
            >
              {isExtracting ? 'Extracting...' : 'Extract Tables'}
            </button>
            {error && (
              <div style={{ marginTop: '10px', padding: '10px', background: '#ffe6e6', borderRadius: '4px', color: '#cc0000', fontSize: '13px' }}>
                {error}
              </div>
            )}
          </div>

          {tables.length > 0 && (
            <div>
              <h4 style={{ marginBottom: '10px', color: 'var(--secondary)' }}>Extracted Tables ({tables.length})</h4>
              {tables.map(table => (
                <div key={table.id} style={{
                  padding: '15px',
                  background: 'white',
                  border: '1px solid var(--border)',
                  borderRadius: '6px',
                  marginBottom: '10px'
                }}>
                  <div
                    style={{ fontWeight: 600, marginBottom: '5px', cursor: 'pointer', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}
                    onClick={() => setExpandedTable(expandedTable === table.id ? null : table.id)}
                  >
                    <span>{table.caption || `Table ${table.id}`}</span>
                    <span style={{ fontSize: '12px', color: '#7f8c8d' }}>
                      {expandedTable === table.id ? 'â–¼' : 'â–¶'}
                    </span>
                  </div>
                  <div style={{ fontSize: '12px', color: '#7f8c8d', marginBottom: expandedTable === table.id ? '10px' : '0' }}>
                    Page {table.page} â€¢ {table.rowCount || table.rows?.length || 0} rows Ã— {table.colCount || table.headers?.length || 0} columns
                  </div>

                  {expandedTable === table.id && table.raw && (
                    <div style={{ overflowX: 'auto', marginTop: '10px' }}>
                      <table style={{ width: '100%', borderCollapse: 'collapse', fontSize: '12px' }}>
                        <thead>
                          <tr>
                            {(table.headers || []).map((header, idx) => (
                              <th key={idx} style={{
                                padding: '8px',
                                background: 'var(--primary)',
                                color: 'white',
                                border: '1px solid var(--border)',
                                textAlign: 'left'
                              }}>
                                {header}
                              </th>
                            ))}
                          </tr>
                        </thead>
                        <tbody>
                          {(table.rows || []).map((row, rowIdx) => (
                            <tr key={rowIdx}>
                              {row.map((cell, cellIdx) => (
                                <td key={cellIdx} style={{
                                  padding: '8px',
                                  border: '1px solid var(--border)',
                                  background: rowIdx % 2 === 0 ? '#f9f9f9' : 'white'
                                }}>
                                  {cell}
                                </td>
                              ))}
                            </tr>
                          ))}
                        </tbody>
                      </table>
                    </div>
                  )}
                </div>
              ))}
            </div>
          )}
        </div>
      );
    }

    function FiguresInterface({ pdfDoc, pdfFile, figures, onFiguresExtracted }) {
      const [isExtracting, setIsExtracting] = useState(false);
      const [error, setError] = useState(null);
      const [selectedFigure, setSelectedFigure] = useState(null);

      const extractFigures = async () => {
        if (!pdfFile) {
          setError('Please upload a PDF file first');
          return;
        }
        setIsExtracting(true);
        setError(null);

        try {
          // Convert PDF to base64
          const arrayBuffer = await pdfFile.arrayBuffer();
          const base64 = btoa(
            new Uint8Array(arrayBuffer).reduce((data, byte) => data + String.fromCharCode(byte), '')
          );

          // Call Python Cloud Function
          const response = await fetch('http://127.0.0.1:5001/cerebellar-sdc/us-central1/extract_figures_enhanced', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ pdf_base64: base64, min_size: 50, dpi: 150 })
          });

          const result = await response.json();

          if (result.success) {
            const extractedFigures = result.figures.map((figure, idx) => ({
              id: idx + 1,
              page: figure.page,
              caption: figure.caption || `Figure ${figure.figure_index + 1}`,
              imageBase64: figure.image_base64,
              width: figure.width,
              height: figure.height,
              format: figure.format,
              bbox: figure.bbox
            }));
            onFiguresExtracted(extractedFigures);
            console.log(`âœ… Extracted ${extractedFigures.length} figures`);
          } else {
            throw new Error(result.error || 'Figure extraction failed');
          }
        } catch (error) {
          console.error('Figure extraction error:', error);
          setError(error.message);
        } finally {
          setIsExtracting(false);
        }
      };

      return (
        <div style={{ padding: '20px' }}>
          <div style={{ marginBottom: '20px' }}>
            <h3 style={{ marginBottom: '10px', color: 'var(--secondary)' }}>ðŸ–¼ï¸ Figure Extraction</h3>
            <p style={{ fontSize: '13px', color: '#7f8c8d', marginBottom: '15px' }}>
              Extract figures, images, and diagrams from the PDF with automatic caption detection.
            </p>
            <button
              onClick={extractFigures}
              disabled={!pdfFile || isExtracting}
              style={{
                padding: '10px 20px',
                background: 'var(--primary)',
                color: 'white',
                border: 'none',
                borderRadius: '4px',
                cursor: pdfFile && !isExtracting ? 'pointer' : 'not-allowed',
                opacity: pdfFile && !isExtracting ? 1 : 0.6
              }}
            >
              {isExtracting ? 'Extracting...' : 'Extract Figures'}
            </button>
            {error && (
              <div style={{ marginTop: '10px', padding: '10px', background: '#ffe6e6', borderRadius: '4px', color: '#cc0000', fontSize: '13px' }}>
                {error}
              </div>
            )}
          </div>

          {figures.length > 0 && (
            <div>
              <h4 style={{ marginBottom: '10px', color: 'var(--secondary)' }}>Extracted Figures ({figures.length})</h4>
              <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(200px, 1fr))', gap: '15px' }}>
                {figures.map(figure => (
                  <div key={figure.id} style={{
                    padding: '10px',
                    background: 'white',
                    border: selectedFigure === figure.id ? '2px solid var(--primary)' : '1px solid var(--border)',
                    borderRadius: '6px',
                    cursor: 'pointer'
                  }}
                  onClick={() => setSelectedFigure(selectedFigure === figure.id ? null : figure.id)}
                  >
                    {figure.imageBase64 && (
                      <img
                        src={`data:image/png;base64,${figure.imageBase64}`}
                        alt={figure.caption}
                        style={{
                          width: '100%',
                          height: '120px',
                          objectFit: 'contain',
                          background: '#f5f5f5',
                          borderRadius: '4px',
                          marginBottom: '8px'
                        }}
                      />
                    )}
                    <div style={{ fontWeight: 600, fontSize: '12px', marginBottom: '3px', overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}>
                      {figure.caption || `Figure ${figure.id}`}
                    </div>
                    <div style={{ fontSize: '11px', color: '#7f8c8d' }}>
                      Page {figure.page} â€¢ {figure.width}Ã—{figure.height}px
                    </div>
                  </div>
                ))}
              </div>

              {selectedFigure && (
                <div style={{
                  marginTop: '20px',
                  padding: '15px',
                  background: 'white',
                  border: '1px solid var(--border)',
                  borderRadius: '6px'
                }}>
                  <h4 style={{ marginBottom: '10px' }}>Figure Details</h4>
                  {(() => {
                    const figure = figures.find(f => f.id === selectedFigure);
                    if (!figure) return null;
                    return (
                      <div>
                        <div style={{ display: 'flex', gap: '20px' }}>
                          <div style={{ flex: '0 0 300px' }}>
                            {figure.imageBase64 && (
                              <img
                                src={`data:image/png;base64,${figure.imageBase64}`}
                                alt={figure.caption}
                                style={{
                                  width: '100%',
                                  border: '1px solid var(--border)',
                                  borderRadius: '4px'
                                }}
                              />
                            )}
                          </div>
                          <div style={{ flex: 1 }}>
                            <p><strong>Caption:</strong> {figure.caption || 'No caption detected'}</p>
                            <p><strong>Page:</strong> {figure.page}</p>
                            <p><strong>Dimensions:</strong> {figure.width} Ã— {figure.height} pixels</p>
                            <p><strong>Format:</strong> {figure.format || 'Unknown'}</p>
                            {figure.bbox && (
                              <p><strong>Bounding Box:</strong> [{figure.bbox.map(v => v.toFixed(1)).join(', ')}]</p>
                            )}
                          </div>
                        </div>
                      </div>
                    );
                  })()}
                </div>
              )}
            </div>
          )}
        </div>
      );
    }

    function ExtractionForm({ data, highlights, pdfFile, currentField, aiFilledFields, onUpdate, onFieldSelect, onExport, onGoToHighlight, onSmartSuggest, onQualityCheck, onGenerateCitation, citations, activeCitation, onCitationSelect, validationErrors = [], validationWarnings = [], isValidating = false, lastValidationTime = null }) {
      const currentPath = FIELD_MAP[currentField];
      const [collapsed, setCollapsed] = useState({ pop: false, int: false, out: false, meta: false, cit: false, analysis: false, validation: false });
      const toggle = (sec) => setCollapsed(prev => ({ ...prev, [sec]: !prev[sec] }));

      const Input = ({ label, path, type = "text", rows }) => {
        const val = path.split('.').reduce((o, i) => o[i], data);
        const isAi = aiFilledFields.has(path);
        const isFocused = currentPath === path;
        const [isSuggesting, setIsSuggesting] = useState(false);

        const triggerSuggest = async () => {
          setIsSuggesting(true);
          await onSmartSuggest(label, path);
          setIsSuggesting(false);
        };

        return (
          <div className="form-group">
            <label>{label}</label>
            <div className="input-wrapper">
              {rows ? (
                <textarea className={`form-control ${isAi ? 'ai-filled' : ''} ${isFocused ? 'field-focused' : ''}`}
                  value={val} onChange={e => onUpdate(path, e.target.value)}
                  onFocus={() => onFieldSelect(Object.keys(FIELD_MAP).find(key => FIELD_MAP[key] === path))} rows={rows} />
              ) : (
                <input className={`form-control ${isAi ? 'ai-filled' : ''} ${isFocused ? 'field-focused' : ''}`}
                  type={type} value={val} onChange={e => onUpdate(path, e.target.value)}
                  onFocus={() => onFieldSelect(Object.keys(FIELD_MAP).find(key => FIELD_MAP[key] === path))} />
              )}
              <div className="input-actions">
                <button className={`btn-suggest ${isSuggesting ? 'loading' : ''}`}
                  onClick={triggerSuggest} title="Ask Gemini to find this" type="button">
                  <Icons.Wand2 size={14} />
                </button>
              </div>
            </div>
          </div>
        );
      };

      return (
        <div className="extraction-form-container">
          {/* Real-time Validation Status Panel */}
          {(validationErrors.length > 0 || validationWarnings.length > 0 || isValidating) && (
            <div className="validation-panel" style={{
              marginBottom: '15px',
              padding: '12px 15px',
              borderRadius: '6px',
              background: validationErrors.length > 0 ? '#fff5f5' : validationWarnings.length > 0 ? '#fffaf0' : '#f0f9ff',
              border: `1px solid ${validationErrors.length > 0 ? '#feb2b2' : validationWarnings.length > 0 ? '#fbd38d' : '#90cdf4'}`
            }}>
              <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: validationErrors.length + validationWarnings.length > 0 ? '8px' : '0' }}>
                <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                  {isValidating ? (
                    <>
                      <span style={{ animation: 'spin 1s linear infinite', display: 'inline-block' }}>â³</span>
                      <span style={{ fontSize: '12px', fontWeight: 600, color: '#3182ce' }}>Validating...</span>
                    </>
                  ) : validationErrors.length > 0 ? (
                    <>
                      <span>âŒ</span>
                      <span style={{ fontSize: '12px', fontWeight: 600, color: '#c53030' }}>
                        {validationErrors.length} Validation Error{validationErrors.length !== 1 ? 's' : ''}
                      </span>
                    </>
                  ) : validationWarnings.length > 0 ? (
                    <>
                      <span>âš ï¸</span>
                      <span style={{ fontSize: '12px', fontWeight: 600, color: '#c05621' }}>
                        {validationWarnings.length} Warning{validationWarnings.length !== 1 ? 's' : ''}
                      </span>
                    </>
                  ) : (
                    <>
                      <span>âœ…</span>
                      <span style={{ fontSize: '12px', fontWeight: 600, color: '#2f855a' }}>Validated</span>
                    </>
                  )}
                </div>
                {lastValidationTime && (
                  <span style={{ fontSize: '10px', color: '#718096' }}>Last checked: {lastValidationTime}</span>
                )}
              </div>

              {validationErrors.length > 0 && (
                <div style={{ marginBottom: validationWarnings.length > 0 ? '8px' : '0' }}>
                  {validationErrors.map((err, idx) => (
                    <div key={idx} style={{
                      fontSize: '11px',
                      color: '#c53030',
                      padding: '4px 8px',
                      background: '#fed7d7',
                      borderRadius: '4px',
                      marginBottom: '4px'
                    }}>
                      â€¢ {err}
                    </div>
                  ))}
                </div>
              )}

              {validationWarnings.length > 0 && (
                <div>
                  {validationWarnings.map((warn, idx) => (
                    <div key={idx} style={{
                      fontSize: '11px',
                      color: '#c05621',
                      padding: '4px 8px',
                      background: '#feebc8',
                      borderRadius: '4px',
                      marginBottom: '4px'
                    }}>
                      â€¢ {warn}
                    </div>
                  ))}
                </div>
              )}
            </div>
          )}

          <div className="form-section">
            <div className="section-header" onClick={() => toggle('meta')}>
              <div className="section-title">ðŸ†” Study Identification</div>
              <Icons.ChevronDown size={16} style={{ transform: collapsed.meta ? 'rotate(-90deg)' : '' }} />
            </div>
            <div className={`section-body ${collapsed.meta ? 'collapsed' : ''}`}>
              <div style={{ display: 'flex', alignItems: 'center', marginBottom: 10 }}>
                <button className="btn-quality-check" onClick={onGenerateCitation} style={{ marginLeft: 0 }}>
                  <Icons.Quote size={12} /> Generate Citation
                </button>
              </div>
              <Input label="Study ID" path="study_id" />
              <Input label="Authors" path="authors" />
              <div style={{ display: 'flex', gap: '10px' }}>
                <div style={{ flex: 1 }}><Input label="Year" path="year" /></div>
                <div style={{ flex: 2 }}><Input label="Design" path="study_design" /></div>
              </div>
              <Input label="Title" path="title" />
            </div>
          </div>

          <div className="form-section">
            <div className="section-header" onClick={() => toggle('pop')}>
              <div className="section-title">ðŸ‘¥ Population</div>
            </div>
            <div className={`section-body ${collapsed.pop ? 'collapsed' : ''}`}>
              <div style={{ display: 'flex', gap: '10px' }}>
                <div style={{ flex: 1 }}><Input label="Sample Size" path="population.sample_size" /></div>
                <div style={{ flex: 1 }}><Input label="Mean Age" path="population.mean_age" /></div>
              </div>
              <Input label="Inclusion Criteria" path="population.inclusion_criteria" rows={3} />
            </div>
          </div>

          <div className="form-section">
            <div className="section-header" onClick={() => toggle('int')}>
              <div className="section-title">ðŸ’‰ Intervention</div>
            </div>
            <div className={`section-body ${collapsed.int ? 'collapsed' : ''}`}>
              <Input label="Procedure" path="intervention.procedure" />
              <Input label="Timing (Hours)" path="intervention.timing_hours" />
              <Input label="Technique" path="intervention.technique" rows={2} />
              <Input label="Comparator" path="comparator" />
            </div>
          </div>

          <div className="form-section">
            <div className="section-header" onClick={() => toggle('out')}>
              <div className="section-title">ðŸ“‰ Outcomes</div>
            </div>
            <div className={`section-body ${collapsed.out ? 'collapsed' : ''}`}>
              <div style={{ display: 'flex', gap: '10px' }}>
                <div style={{ flex: 1 }}><Input label="Mortality" path="outcomes.mortality" /></div>
                <div style={{ flex: 1 }}><Input label="Favorable Outcome" path="outcomes.mRS_favorable" /></div>
              </div>
              <Input label="Complications" path="outcomes.complications" rows={3} />
              <Input label="Length of Stay" path="outcomes.length_of_stay" />

              <div style={{ marginTop: 15, paddingTop: 15, borderTop: '1px dashed #eee' }}>
                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: 5 }}>
                  <label style={{ fontSize: 12, fontWeight: 600, color: '#7f8c8d', textTransform: 'uppercase' }}>Quality Score</label>
                  <button className="btn-quality-check" onClick={onQualityCheck}>
                    <Icons.Activity size={12} /> Analyze Quality
                  </button>
                </div>
                <Input label="" path="newcastle_ottawa_score" />
              </div>
            </div>
          </div>

          {/* Citation Provenance Panel */}
          {citations && citations.length > 0 && (
            <div className="citation-panel">
              <div className="citation-panel-header" onClick={() => toggle('cit')}>
                <span>ðŸ“Ž Verified Citations ({citations.length})</span>
                <Icons.ChevronDown size={16} style={{ marginLeft: 'auto', transform: collapsed.cit ? 'rotate(-90deg)' : '' }} />
              </div>
              {!collapsed.cit && citations.map((cit, idx) => (
                <div
                  key={cit.id || idx}
                  className={`citation-card ${activeCitation?.id === cit.id ? 'active' : ''}`}
                  onClick={() => onCitationSelect(cit)}
                >
                  <div className="citation-field">{cit.field || 'Extracted Value'}</div>
                  <div className="citation-value">{cit.value || cit.citedText?.substring(0, 60)}</div>
                  <div className="citation-source">
                    "{cit.sourceText || cit.citedText}"
                  </div>
                  <div className="citation-meta">
                    <span>Page {cit.page}</span>
                    <span>Chars {cit.startChar}-{cit.endChar}</span>
                  </div>
                </div>
              ))}
            </div>
          )}

          {(highlights[pdfFile] || []).length > 0 && (
            <div className="annotations-container">
              <h3 style={{ fontSize: '12px', fontWeight: 600, color: '#777', marginBottom: '10px', marginTop: '20px' }}>CAPTURED SNIPPETS</h3>
              {(highlights[pdfFile] || []).map(h => (
                <div key={h.id} className="annotation-card" onClick={() => onGoToHighlight(h.page)}>
                  <strong>{h.field} (Pg {h.page})</strong>
                  <p>{h.text}</p>
                </div>
              ))}
            </div>
          )}

          {/* Analysis Section */}
          <div className="form-section">
            <div className="section-header" onClick={() => toggle('analysis')}>
              <span className="section-title">
                <Icons.Activity size={16} style={{ marginRight: 6 }} />
                ðŸ“Š Quality Analysis
              </span>
              <Icons.ChevronDown size={16} style={{ transform: collapsed.analysis ? 'rotate(-90deg)' : '', transition: 'transform 0.2s' }} />
            </div>
            <div className={`section-body ${collapsed.analysis ? 'collapsed' : ''}`}>
              <div style={{ padding: '10px', background: '#f8f9fa', borderRadius: '4px', marginBottom: '15px' }}>
                <h4 style={{ fontSize: '13px', fontWeight: 600, marginBottom: '8px', color: 'var(--secondary)' }}>
                  Extraction Quality Report
                </h4>
                <p style={{ fontSize: '12px', color: '#7f8c8d', marginBottom: '10px' }}>
                  Automated quality checks using the 3-layer critique system (Layer 1: Math validators, Layer 2: Semantic logic, Layer 3: Evidence anchoring).
                </p>
                <button
                  onClick={onQualityCheck}
                  style={{
                    padding: '8px 16px',
                    background: 'var(--primary)',
                    color: 'white',
                    border: 'none',
                    borderRadius: '4px',
                    cursor: 'pointer',
                    fontSize: '12px',
                    fontWeight: 600
                  }}
                >
                  <Icons.Activity size={12} style={{ marginRight: '4px', display: 'inline', verticalAlign: 'middle' }} />
                  Run Quality Analysis
                </button>
              </div>

              <div style={{ marginTop: '15px' }}>
                <h5 style={{ fontSize: '12px', fontWeight: 600, marginBottom: '8px', color: 'var(--secondary)' }}>
                  Completeness Check
                </h5>
                <div style={{ fontSize: '12px', color: '#555' }}>
                  {[
                    { label: 'Metadata', fields: ['study_id', 'authors', 'year', 'title'], icon: 'ðŸ“‹' },
                    { label: 'Population', fields: ['population.sample_size', 'population.mean_age'], icon: 'ðŸ‘¥' },
                    { label: 'Intervention', fields: ['intervention.procedure', 'intervention.technique'], icon: 'âš•ï¸' },
                    { label: 'Outcomes', fields: ['outcomes.mortality', 'outcomes.mRS_favorable'], icon: 'ðŸ“Š' }
                  ].map((section, idx) => {
                    const completedCount = section.fields.filter(field => {
                      const keys = field.split('.');
                      let val = data;
                      for (const key of keys) val = val?.[key];
                      return val && val !== '';
                    }).length;
                    const total = section.fields.length;
                    const pct = Math.round((completedCount / total) * 100);
                    return (
                      <div key={idx} style={{ marginBottom: '8px', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                        <span>{section.icon} {section.label}</span>
                        <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                          <div style={{ width: '100px', height: '6px', background: '#eee', borderRadius: '3px', overflow: 'hidden' }}>
                            <div style={{ width: `${pct}%`, height: '100%', background: pct === 100 ? 'var(--success)' : 'var(--accent)' }} />
                          </div>
                          <span style={{ fontSize: '11px', fontWeight: 600, color: pct === 100 ? 'var(--success)' : '#7f8c8d' }}>
                            {completedCount}/{total}
                          </span>
                        </div>
                      </div>
                    );
                  })}
                </div>
              </div>
            </div>
          </div>

          <div className="panel-footer" style={{ marginTop: 20, padding: 0, borderTop: 'none' }}>
            <button className="action-btn btn-export-json" onClick={onExport}>Download JSON</button>
          </div>
        </div>
      );
    }

    function PDFPanel({
      pdfFile, pdfDoc, pageNum, numPages, highlights,
      currentField, selectionMode, onFileUpload, onPageChange,
      onFieldSelect, onSelectionModeToggle, onAddHighlight, onClearHighlights,
      citationHighlights, activeCitation, onCitationClick, onViewportChange,
      availablePDFs, selectedPDFDropdown, onPDFDropdownChange
    }) {
      const canvasRef = useRef(null);
      const [scale, setScale] = useState(1.2);
      const [textContent, setTextContent] = useState(null);
      const [viewport, setViewport] = useState(null);

      useEffect(() => {
        if (pdfDoc) renderPage();
      }, [pdfDoc, pageNum, scale]);

      useEffect(() => {
        const canvas = canvasRef.current;
        if (!selectionMode || !canvas || !textContent) return;

        let startX, startY, isDrawing = false;
        let selectionBox = document.createElement('div');
        selectionBox.style.cssText = 'position:absolute; border: 2px dashed #f39c12; background: rgba(243, 156, 18, 0.2); pointer-events: none; z-index: 50;';

        const getCoords = (e) => {
          const rect = canvas.getBoundingClientRect();
          return { x: e.clientX - rect.left, y: e.clientY - rect.top };
        };

        const onDown = (e) => {
          const { x, y } = getCoords(e);
          startX = x; startY = y;
          isDrawing = true;
          selectionBox.style.left = x + 'px'; selectionBox.style.top = y + 'px';
          canvas.parentElement.appendChild(selectionBox);
        };

        const onMove = (e) => {
          if (!isDrawing) return;
          const { x, y } = getCoords(e);
          const left = Math.min(startX, x), top = Math.min(startY, y);
          const width = Math.abs(x - startX), height = Math.abs(y - startY);
          selectionBox.style.left = left + 'px'; selectionBox.style.top = top + 'px';
          selectionBox.style.width = width + 'px'; selectionBox.style.height = height + 'px';
        };

        const onUp = (e) => {
          if (!isDrawing) return;
          isDrawing = false;
          const { x, y } = getCoords(e);
          selectionBox.remove();
          const rect = {
            left: Math.min(startX, x), top: Math.min(startY, y),
            width: Math.abs(x - startX), height: Math.abs(y - startY)
          };
          if (rect.width < 5 || rect.height < 5) return;
          onAddHighlight(rect, "Selected Text (Simulated Extraction)");
        };

        canvas.addEventListener('mousedown', onDown);
        window.addEventListener('mousemove', onMove);
        window.addEventListener('mouseup', onUp);

        return () => {
          canvas.removeEventListener('mousedown', onDown);
          window.removeEventListener('mousemove', onMove);
          window.removeEventListener('mouseup', onUp);
          if (selectionBox.parentNode) selectionBox.parentNode.removeChild(selectionBox);
        };
      }, [selectionMode, textContent]);

      const renderPage = async () => {
        try {
          const page = await pdfDoc.getPage(pageNum);
          const vp = page.getViewport({ scale });
          setViewport(vp);
          if (onViewportChange) onViewportChange(vp);

          const canvas = canvasRef.current;
          const ctx = canvas.getContext('2d');
          canvas.width = vp.width;
          canvas.height = vp.height;
          await page.render({ canvasContext: ctx, viewport: vp }).promise;
          const text = await page.getTextContent();
          setTextContent(text);
        } catch (e) { console.error(e); }
      };

      return (
        <div className="pdf-panel">
          <div className="pdf-header">
            <h2>ðŸ“„ PDF Explorer</h2>
            <div style={{ display: 'flex', gap: '8px', alignItems: 'center' }}>
              <select
                value={selectedPDFDropdown}
                onChange={e => onPDFDropdownChange(e.target.value)}
                style={{
                  padding: '8px 12px',
                  background: '#f8f9fa',
                  border: '1px solid var(--border)',
                  borderRadius: '4px',
                  fontSize: '13px',
                  cursor: 'pointer',
                  minWidth: '150px'
                }}
              >
                <option value="">Select from Library</option>
                {availablePDFs.map((pdf, idx) => {
                  const highlightCount = (highlights[pdf.filename] || []).length;
                  const badge = highlightCount > 0 ? ` (${highlightCount} highlights)` : '';
                  return (
                    <option key={idx} value={pdf.filename}>
                      {pdf.name}{badge}
                    </option>
                  );
                })}
              </select>
              <span style={{ color: '#999', fontSize: '12px' }}>or</span>
              <label className="file-upload-btn">
                Upload PDF
                <input type="file" accept=".pdf" onChange={e => handleFileUpload(e.target.files[0])} />
              </label>
            </div>
          </div>

          {pdfFile && (
            <div className="pdf-controls">
              <button className="control-btn" onClick={() => onPageChange(Math.max(1, pageNum - 1))} disabled={pageNum <= 1}>Previous</button>
              <span style={{ fontSize: '12px', margin: '0 10px' }}>Page {pageNum} / {numPages}</span>
              <button className="control-btn" onClick={() => onPageChange(Math.min(numPages, pageNum + 1))} disabled={pageNum >= numPages}>Next</button>
              <div style={{ width: '1px', height: '16px', background: '#666', margin: '0 10px' }}></div>
              <button className="control-btn" onClick={() => setScale(s => Math.max(0.5, s - 0.2))}>-</button>
              <span style={{ fontSize: '12px' }}>{Math.round(scale * 100)}%</span>
              <button className="control-btn" onClick={() => setScale(s => Math.min(3, s + 0.2))}>+</button>
            </div>
          )}

          <div className="annotation-bar">
            <select className="field-select" value={currentField} onChange={e => onFieldSelect(e.target.value)}>
              <option value="">-- Select Field to Extract --</option>
              {Object.keys(FIELD_MAP).map(k => <option key={k} value={k}>{k}</option>)}
            </select>

            <button
              className={`toggle-highlight-btn ${selectionMode ? 'active' : ''}`}
              onClick={() => onSelectionModeToggle(!selectionMode)}
              disabled={!currentField}
              title={!currentField ? "Select a field first" : "Click and drag on PDF"}
            >
              {selectionMode ? 'ðŸ–ï¸ Highlighting...' : 'Enable Selection'}
            </button>

            {pdfFile && (highlights[pdfFile] || []).length > 0 && (
              <button
                className="control-btn"
                onClick={onClearHighlights}
                title={`Clear ${(highlights[pdfFile] || []).length} highlight${(highlights[pdfFile] || []).length !== 1 ? 's' : ''} for this PDF`}
                style={{ marginLeft: '8px', background: '#e74c3c', color: 'white' }}
              >
                ðŸ—‘ï¸ Clear Highlights ({(highlights[pdfFile] || []).length})
              </button>
            )}
          </div>

          <div className="pdf-viewer-container">
            {pdfFile ? (
              <div className="pdf-canvas-wrapper">
                <canvas ref={canvasRef} id="pdf-canvas" style={{ cursor: selectionMode ? 'crosshair' : 'default' }} />
                <div className="highlight-layer">
                  {/* Manual selection highlights (yellow) with tooltips showing field name */}
                  {(highlights[pdfFile] || []).filter(h => h.page === pageNum).map(h => (
                    <div key={h.id} className="highlight"
                      style={{ left: h.rect.left, top: h.rect.top, width: h.rect.width, height: h.rect.height }}
                      title={h.field + ": " + h.text} />
                  ))}

                  {/* Claude citation highlights (purple) */}
                  {viewport && citationHighlights && citationHighlights
                    .filter(c => c.page === pageNum)
                    .map((c, idx) => {
                      const rect = pdfToCanvasCoords(c.x, c.y, c.width, c.height, viewport);
                      const isActive = activeCitation && activeCitation.id === c.id;
                      return (
                        <div
                          key={`cit-${idx}-${c.page}`}
                          className={`citation-highlight ${isActive ? 'active' : ''}`}
                          style={{
                            left: rect.left,
                            top: rect.top,
                            width: Math.max(rect.width, 10),
                            height: Math.max(rect.height, 12)
                          }}
                          title={`Citation: "${c.citedText?.substring(0, 50)}..."`}
                          onClick={() => onCitationClick && onCitationClick(c)}
                        />
                      );
                    })}
                </div>
              </div>
            ) : (
              <div style={{ textAlign: 'center', marginTop: '100px', opacity: 0.5, color: '#333' }}>
                <div style={{ fontSize: '40px', marginBottom: '20px' }}>ðŸ“„</div>
                <div>Upload a PDF Document to begin</div>
              </div>
            )}
          </div>
        </div>
      );
    }

    ReactDOM.render(<App />, document.getElementById('root'));
  </script>

  <!-- ðŸ¤– Google Generative AI (Gemini) - Browser-compatible SDK -->
  <script type="module">
    import { GoogleGenerativeAI } from 'https://esm.sh/@google/generative-ai';

    // âš ï¸ API key visible in browser - OK for dev, not for production
    const API_KEY = 'AIzaSyA0q3GpEymeImQKwJn3g226CYLncCJaOCc';

    // Initialize the Gemini client
    const genAI = new GoogleGenerativeAI(API_KEY);
    const model = genAI.getGenerativeModel({ model: 'gemini-3-pro-preview' });

    // Example: Hello flow equivalent
    async function helloFlow(name) {
      try {
        const result = await model.generateContent(`Hello Gemini, my name is ${name}`);
        const response = await result.response;
        const text = response.text();
        console.log('Gemini response:', text);
        return text;
      } catch (error) {
        console.error('Gemini error:', error);
      }
    }

    // Make it globally accessible for testing
    window.helloFlow = helloFlow;
    window.geminiModel = model;

    // Test call (uncomment to run on page load)
    // helloFlow('Chris');

    console.log('âœ… Google Generative AI SDK loaded. Try: helloFlow("YourName") in console');
  </script>
</body>

</html>